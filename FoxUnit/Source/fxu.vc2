*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="fxu.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS frmfoxunit AS fxufrmuser OF "fxu.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Sfsplitterv1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTests" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTests.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTests.Column1.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTests.Column2.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTests.Column2.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfDetails" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfDetails.pgFailuresAndErrors.edtFailuresAndErrors" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfDetails.pgFailuresAndErrors.cmdCompare" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfDetails.pgMessages.edtMessages" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="shpButtons" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdLoadNewTestClass" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRunTestsAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRunTestsOneClass" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pbProgress" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdReloadSelectedTestClass" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRemoveTestClass" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCreateNewTestClass" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRunTestsOne" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTestsRunTestsFailed" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAddNewTest" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblElapsedTime" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTimeElapsed" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdModifySelected" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="shpSeparator1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="shpSeparator2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOptions" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblAllResults" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblRun" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTestClass" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCloseAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblFoxUnit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilterResults" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilterResults.txtClassFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilterResults.txtNameFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilterResults.lblClassFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilterResults.lblNameFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilterResults.chkFailedOnly" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilterResults.shpFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilterResults.lblFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntFilterResults.cmdReset" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addshortcutoption_classaddtest
		*m: addshortcutoption_classload
		*m: addshortcutoption_classnew
		*m: addshortcutoption_detailsprint
		*m: addshortcutoption_detailszoom
		*m: addshortcutoption_formacknowledgements
		*m: addshortcutoption_formclose
		*m: addshortcutoption_formfont
		*m: addshortcutoption_formlicense
		*m: addshortcutoption_formoptions
		*m: addshortcutoption_formresetfont
		*m: addshortcutoption_gridresetcolumnwidths
		*m: addshortcutoption_gridsize
		*m: addshortcutoption_gridsortbylocation
		*m: addshortcutoption_gridsortbyname
		*m: addshortcutoption_runtestsall
		*m: addshortcutoption_runtestsclass
		*m: addshortcutoption_runtestselected
		*m: addshortcutoption_selectedmodify
		*m: addshortcutoption_selectedreload
		*m: addshortcutoption_selectedremove
		*m: addshortcutoption_separator
		*m: afterruntests
		*m: applyfilter
		*m: calculaterowcolor		&& Calculates the correct RGB value row color for a test row (grey = not tested, red = falied, green = succeeded)
		*m: clearfilter		&& Clear the results filter
		*m: detailsprint
		*m: detailszoom
		*m: execapplication
		*m: formatsecondselapsed
		*m: formfont
		*m: formresetfont
		*m: getfiltertooltiptext
		*m: gridresetcolumnwidths
		*m: gridsortbylocation
		*m: gridsortbyname
		*m: modifyclassatlinenumber
		*m: movetofirsttestofnextclass
		*m: options
		*m: receivecompletenotification
		*m: receiveresultnotification		&& Recieves results of the current test
		*m: reloadselectedtestclass
		*m: runalltests		&& runs all tests in all test classes that are currently loaded into the thisform.icGridRs table
		*m: runclasstests		&& Runs all tests for the class specified
		*m: runonetest		&& Runs the one test who's row is currently selected in the grid
		*m: saveproperty
		*m: seeiftestclassprgexists
		*m: setallowdebug
		*m: setprogress		&& sets progress bar back to no tests run status
		*m: settestsruntestsfailedlabel
		*m: shellshortcutmenueditbox
		*m: shellshortcutmenuform
		*m: shellshortcutmenugrid
		*m: shortcutmenueditbox
		*m: shortcutmenuform
		*m: shortcutmenugrid
		*m: showprogress		&& Sets the value of the test progress bar as well as the color for pass or fail
		*m: togglefilter		&& Turn filter on/off
		*m: togglegridsize		&& Switch from large/normal grid size and back
		*m: underconstruction
		*m: updatecurrentgridrowcolor
		*m: zreadme
		*p: icclassfilter
		*p: iccompareparameters		&& Parameters passed to the compare tool. %1 and %2 are replaced with temporary file names
		*p: iccomparetool		&& Full path to external file compare tool
		*p: icgridrs		&& THIS.grdTests.RecordSource
		*p: icnamefilter
		*p: ilallowdebug
		*p: ilclosedebuggeratendoftestsrun
		*p: ilhonortestprefix
		*p: ilinitialentry
		*p: illargegrid		&& Showing full size results at expense of details?
		*p: ilreloadtestsonrun
		*p: iltestsfailed
		*p: inbar
		*p: incolorfail		&& Red Color for background color of rows in test grid for tests that failed and the test run progress bar when tests have failed.
		*p: incolornotrun		&& Background color definition for grid rows of tests that weren't run yet, or not run during the last test pass
		*p: incolorpass		&& Green color property used for setting green "pass" color to grid rows and test running status bar
		*p: inmostrecentselectedrow
		*p: inzoomheight
		*p: inzoomleft
		*p: inzoomtop
		*p: inzoomwidth
		*p: inzoomwindowstate
		*p: ioresultdata		&& Results Data Object, controls the test results table and allows update loggin to the table
		*p: iotestbroker		&& Object That decouples the test data session from the foxUnit datasession, enabling tests to run without conflicting with the datasession storing the results.
		*p: iotestresult		&& Class level test result object. Passed to testbroker when running tests. Instantiated when the form is instantiated.
		*p: iresetresults		&& Clear the background grid when running tests
		*p: lfailedonly		&& Filter to show failed tests only
		*p: lfiltered		&& Are the results filtered?
		*p: nsplitterposition
		*a: iaunprintable[1,0]		&& Array lists all characters that are not printable.
	*</DefinedPropArrayMethod>

	AllowOutput = .F.
	AutoCenter = .T.
	Caption = "FoxUnit - The Unit Testing Framework for Visual FoxPro"
	DataSession = 2
	DoCreate = .T.
	FillStyle = 1
	Height = 504
	icclassfilter = 
	iccompareparameters = 		&& Parameters passed to the compare tool. %1 and %2 are replaced with temporary file names
	iccomparetool = 		&& Full path to external file compare tool
	icgridrs = FXUResults		&& THIS.grdTests.RecordSource
	icnamefilter = 
	ilallowdebug = .F.
	ilclosedebuggeratendoftestsrun = .F.
	ilhonortestprefix = .F.
	ilinitialentry = .T.
	illargegrid = .F.		&& Showing full size results at expense of details?
	inbar = 0
	incolorfail = (rgb(255,50,50))		&& Red Color for background color of rows in test grid for tests that failed and the test run progress bar when tests have failed.
	incolornotrun = (rgb(200,200,200))		&& Background color definition for grid rows of tests that weren't run yet, or not run during the last test pass
	incolorpass = (rgb(0,220,0))		&& Green color property used for setting green "pass" color to grid rows and test running status bar
	inmostrecentselectedrow = 1
	inzoomwindowstate = 0
	iofxuinstance = .NULL.
	iresetresults = .T.		&& Clear the background grid when running tests
	lfailedonly = .F.		&& Filter to show failed tests only
	lfiltered = .F.		&& Are the results filtered?
	Name = "frmfoxunit"
	nsplitterposition = 0
	ShowTips = .T.
	ShowWindow = 2
	Visible = .T.
	Width = 803
	_memberdata = <VFPData>
		<memberdata name="nsplitterposition" display="nSplitterPosition"/>
		<memberdata name="reloadselectedtestclass" display="ReloadSelectedTestClass"/>
		<memberdata name="clearfilter" display="clearFilter"/>
		<memberdata name="togglefilter" display="toggleFilter"/>
		<memberdata name="lfiltered" display="lFiltered"/>
		</VFPData>

	ADD OBJECT 'chkFilter' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 8, ;
		Caption = "Filter", ;
		ControlSource = "ThisForm.lFiltered", ;
		Height = 40, ;
		Left = 652, ;
		Name = "chkFilter", ;
		Picture = ..\graphics\filteralphabetically_5567_32.bmp, ;
		SpecialEffect = 1, ;
		Style = 1, ;
		TabIndex = 11, ;
		Top = 0, ;
		Width = 60
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmdAddNewTest' AS commandbutton WITH ;
		Caption = "\<Add", ;
		FontName = "Tahoma", ;
		Height = 40, ;
		Left = 509, ;
		Name = "cmdAddNewTest", ;
		Picture = ..\graphics\importorload_8600_32.bmp, ;
		SpecialEffect = 2, ;
		TabIndex = 9, ;
		TabStop = .F., ;
		ToolTipText = "Add a new Test to the currently selected Test Class ", ;
		Top = 0, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdCloseAll' AS commandbutton WITH ;
		Caption = "Close All", ;
		Height = 40, ;
		Left = 408, ;
		Name = "cmdCloseAll", ;
		Picture = ..\graphics\clearwindowcontent_6304_32.bmp, ;
		SpecialEffect = 2, ;
		TabIndex = 8, ;
		TabStop = .F., ;
		ToolTipText = "See THIS.Init()", ;
		Top = 0, ;
		Width = 56
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdCreateNewTestClass' AS commandbutton WITH ;
		Caption = "\<New", ;
		FontName = "Tahoma", ;
		Height = 40, ;
		Left = 188, ;
		Name = "cmdCreateNewTestClass", ;
		Picture = ..\graphics\newmanualtesttxttype_8618_32.bmp, ;
		SpecialEffect = 2, ;
		TabIndex = 4, ;
		TabStop = .F., ;
		ToolTipText = "Create a new Test Class", ;
		Top = 0, ;
		Width = 56
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdLoadNewTestClass' AS commandbutton WITH ;
		Caption = "\<Open", ;
		FontName = "Tahoma", ;
		Height = 40, ;
		Left = 243, ;
		Name = "cmdLoadNewTestClass", ;
		Picture = ..\graphics\newloadtestplugin_8616_32.bmp, ;
		SpecialEffect = 2, ;
		TabIndex = 5, ;
		TabStop = .F., ;
		ToolTipText = "Load a test class (.PRG) that inherits from FxuTestCase that is not already in the list", ;
		Top = 0, ;
		Width = 56
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdModifySelected' AS commandbutton WITH ;
		Caption = "\<Edit", ;
		FontName = "Tahoma", ;
		Height = 40, ;
		Left = 564, ;
		Name = "cmdModifySelected", ;
		Picture = ..\graphics\behavioreditorpart_6013_24.bmp, ;
		SpecialEffect = 2, ;
		TabIndex = 10, ;
		TabStop = .F., ;
		ToolTipText = "Modify the currently selected Test ", ;
		Top = 0, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOptions' AS commandbutton WITH ;
		Anchor = 8, ;
		Caption = "Options", ;
		FontName = "Tahoma", ;
		Height = 40, ;
		Left = 712, ;
		Name = "cmdOptions", ;
		Picture = ..\graphics\foxunit.bmp, ;
		SpecialEffect = 2, ;
		TabIndex = 12, ;
		TabStop = .F., ;
		ToolTipText = "FoxUnit Options", ;
		Top = 0, ;
		Width = 90
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdReloadSelectedTestClass' AS commandbutton WITH ;
		Caption = "Refresh", ;
		FontName = "Tahoma", ;
		Height = 40, ;
		Left = 298, ;
		Name = "cmdReloadSelectedTestClass", ;
		Picture = ..\graphics\reloadxml_7509_32.bmp, ;
		SpecialEffect = 2, ;
		TabIndex = 6, ;
		TabStop = .F., ;
		ToolTipText = "Refresh the results table for the Test Class containing the selected Test", ;
		Top = 0, ;
		Width = 56
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdRemoveTestClass' AS commandbutton WITH ;
		Caption = "Close", ;
		Height = 40, ;
		Left = 353, ;
		Name = "cmdRemoveTestClass", ;
		Picture = ..\graphics\close_6519_24.bmp, ;
		SpecialEffect = 2, ;
		TabIndex = 7, ;
		TabStop = .F., ;
		ToolTipText = "See THIS.Init()", ;
		Top = 0, ;
		Width = 56
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdRunTestsAll' AS commandbutton WITH ;
		Caption = "\<Run All", ;
		FontName = "Tahoma", ;
		Height = 40, ;
		Left = 5, ;
		Name = "cmdRunTestsAll", ;
		Picture = ..\graphics\debugalltests_10483_32.bmp, ;
		SpecialEffect = 2, ;
		TabIndex = 1, ;
		TabStop = .F., ;
		ToolTipText = "Run all the tests in the loaded test classes", ;
		Top = 0, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdRunTestsOne' AS commandbutton WITH ;
		Caption = "\<Selected", ;
		FontName = "Tahoma", ;
		Height = 40, ;
		Left = 113, ;
		Name = "cmdRunTestsOne", ;
		Picture = ..\graphics\debugselection_8607_32.bmp, ;
		SpecialEffect = 2, ;
		TabIndex = 3, ;
		TabStop = .F., ;
		ToolTipText = "Run only the currently selected Test", ;
		Top = 0, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdRunTestsOneClass' AS commandbutton WITH ;
		Caption = "\<Class", ;
		FontName = "Tahoma", ;
		Height = 40, ;
		Left = 59, ;
		Name = "cmdRunTestsOneClass", ;
		Picture = ..\graphics\debugcheckedtests_10485_32.bmp, ;
		SpecialEffect = 2, ;
		TabIndex = 2, ;
		TabStop = .F., ;
		ToolTipText = "Run all the tests in the currently-selected test class", ;
		Top = 0, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cntFilterResults' AS container WITH ;
		Anchor = 10, ;
		BorderWidth = 0, ;
		Height = 39, ;
		Left = 0, ;
		Name = "cntFilterResults", ;
		TabIndex = 13, ;
		Top = 54, ;
		Visible = .F., ;
		Width = 828
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'cntFilterResults.chkFailedOnly' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 8, ;
		AutoSize = .T., ;
		Caption = "Failed Tests Only", ;
		ControlSource = "ThisForm.lFailedOnly", ;
		Height = 17, ;
		Left = 395, ;
		Name = "chkFailedOnly", ;
		Top = 5, ;
		Width = 113
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cntFilterResults.cmdReset' AS commandbutton WITH ;
		Anchor = 9, ;
		Caption = "Reset", ;
		FontName = "Tahoma", ;
		Height = 39, ;
		Left = 747, ;
		Name = "cmdReset", ;
		Picture = ..\graphics\bookmarkclear_2381_32.bmp, ;
		SpecialEffect = 2, ;
		TabIndex = 6, ;
		TabStop = .F., ;
		ToolTipText = "Add a new test (method) to the test class (.PRG) currently selected in the grid.", ;
		Top = -1, ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cntFilterResults.lblClassFilter' AS label WITH ;
		Alignment = 1, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Class Name", ;
		Height = 17, ;
		Left = 6, ;
		Name = "lblClassFilter", ;
		TabIndex = 12, ;
		Top = 3, ;
		Width = 72
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'cntFilterResults.lblFilter' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Filter Tests", ;
		Enabled = .T., ;
		FontSize = 8, ;
		ForeColor = 192,192,192, ;
		Height = 16, ;
		Left = 214, ;
		Name = "lblFilter", ;
		Top = 25, ;
		Width = 55
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'cntFilterResults.lblNameFilter' AS label WITH ;
		Alignment = 1, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Test Name", ;
		Height = 17, ;
		Left = 206, ;
		Name = "lblNameFilter", ;
		TabIndex = 14, ;
		Top = 3, ;
		Width = 63
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'cntFilterResults.shpFilter' AS shape WITH ;
		Anchor = 10, ;
		BackStyle = 0, ;
		Height = 1, ;
		Left = -3, ;
		Name = "shpFilter", ;
		SpecialEffect = 0, ;
		Top = 38, ;
		Width = 806
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'cntFilterResults.txtClassFilter' AS textbox WITH ;
		ControlSource = "THISFORM.icClassFilter", ;
		Height = 23, ;
		Left = 86, ;
		MaxLength = 110, ;
		Name = "txtClassFilter", ;
		TabIndex = 20, ;
		Top = 3, ;
		Width = 108
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'cntFilterResults.txtNameFilter' AS textbox WITH ;
		ControlSource = "THISFORM.icNameFilter", ;
		Height = 23, ;
		Left = 274, ;
		MaxLength = 130, ;
		Name = "txtNameFilter", ;
		TabIndex = 21, ;
		Top = 3, ;
		Width = 108
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdTests' AS grid WITH ;
		ColumnCount = 2, ;
		DeleteMark = .F., ;
		FontName = "Tahoma", ;
		Height = 218, ;
		HighlightStyle = 2, ;
		Left = 8, ;
		Name = "grdTests", ;
		Panel = 1, ;
		ReadOnly = .T., ;
		ScrollBars = 2, ;
		TabIndex = 14, ;
		Top = 56, ;
		Width = 789, ;
		Column1.BackColor = 255,255,255, ;
		Column1.FontBold = .F., ;
		Column1.FontName = "Tahoma", ;
		Column1.Name = "Column1", ;
		Column1.ReadOnly = .T., ;
		Column1.Width = 208, ;
		Column2.BackColor = 255,255,255, ;
		Column2.FontBold = .F., ;
		Column2.FontName = "Tahoma", ;
		Column2.Name = "Column2", ;
		Column2.ReadOnly = .T., ;
		Column2.Width = 550
		*< END OBJECT: BaseClass="grid" />

	ADD OBJECT 'grdTests.Column1.Header1' AS header WITH ;
		Caption = " Test Class (.PRG)", ;
		FontBold = .F., ;
		FontName = "Tahoma", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdTests.Column1.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ControlSource = "tresult.tclass", ;
		FontBold = .F., ;
		FontName = "Tahoma", ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdTests.Column2.Header1' AS header WITH ;
		Caption = " Test name (method of...)", ;
		FontBold = .F., ;
		FontName = "Tahoma", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdTests.Column2.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ControlSource = "tresult.tname", ;
		FontBold = .F., ;
		FontName = "Tahoma", ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'Label1' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Unit Tests", ;
		Enabled = .T., ;
		FontSize = 8, ;
		ForeColor = 192,192,192, ;
		Height = 16, ;
		Left = 538, ;
		Name = "Label1", ;
		TabIndex = 24, ;
		Top = 39, ;
		Width = 50
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblAllResults' AS label WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Test results", ;
		FontName = "Tahoma", ;
		Height = 16, ;
		Left = 648, ;
		Name = "lblAllResults", ;
		TabIndex = 18, ;
		Top = 463, ;
		Width = 66
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblElapsedTime' AS label WITH ;
		Alignment = 0, ;
		BackStyle = 0, ;
		Caption = "Elapsed Time:", ;
		FontName = "Tahoma", ;
		Height = 18, ;
		Left = 360, ;
		Name = "lblElapsedTime", ;
		TabIndex = 19, ;
		Top = 462, ;
		Visible = .F., ;
		Width = 84
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblFoxUnit' AS label WITH ;
		Anchor = 8, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "FoxUnit", ;
		Enabled = .T., ;
		FontSize = 8, ;
		ForeColor = 192,192,192, ;
		Height = 16, ;
		Left = 703, ;
		Name = "lblFoxUnit", ;
		TabIndex = 25, ;
		Top = 38, ;
		Width = 38
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblRun' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Run", ;
		Enabled = .T., ;
		FontSize = 8, ;
		ForeColor = 192,192,192, ;
		Height = 16, ;
		Left = 74, ;
		Name = "lblRun", ;
		TabIndex = 22, ;
		Top = 39, ;
		Width = 21
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblTestClass' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Test Classes", ;
		Enabled = .T., ;
		FontSize = 8, ;
		ForeColor = 192,192,192, ;
		Height = 16, ;
		Left = 294, ;
		Name = "lblTestClass", ;
		TabIndex = 23, ;
		Top = 39, ;
		Width = 65
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblTestsRunTestsFailed' AS label WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Test results", ;
		FontName = "Tahoma", ;
		Height = 16, ;
		Left = 13, ;
		Name = "lblTestsRunTestsFailed", ;
		TabIndex = 17, ;
		Top = 463, ;
		Width = 66
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblTimeElapsed' AS label WITH ;
		BackStyle = 0, ;
		Caption = "", ;
		FontName = "Tahoma", ;
		Height = 18, ;
		Left = 440, ;
		Name = "lblTimeElapsed", ;
		TabIndex = 20, ;
		Top = 451, ;
		Width = 114
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pbProgress' AS cprogressbar WITH ;
		Height = 23, ;
		Left = 14, ;
		Name = "pbProgress", ;
		TabIndex = 21, ;
		Top = 478, ;
		Width = 777, ;
		shpBar.BackColor = 0,0,255, ;
		shpBar.Name = "shpBar", ;
		lblPercent.Name = "lblPercent"
		*< END OBJECT: ClassLib="cprogres.vcx" BaseClass="container" />

	ADD OBJECT 'pgfDetails' AS pageframe WITH ;
		ErasePage = .T., ;
		Height = 170, ;
		Left = 8, ;
		Name = "pgfDetails", ;
		PageCount = 2, ;
		TabIndex = 15, ;
		Top = 279, ;
		Width = 792, ;
		Page1.Caption = "\<Failures and Errors", ;
		Page1.Name = "pgFailuresAndErrors", ;
		Page2.Caption = "Messa\<ges", ;
		Page2.Name = "pgMessages"
		*< END OBJECT: BaseClass="pageframe" />

	ADD OBJECT 'pgfDetails.pgFailuresAndErrors.cmdCompare' AS commandbutton WITH ;
		Caption = "\<Compare", ;
		FontName = "Tahoma", ;
		Height = 40, ;
		Left = 728, ;
		Name = "cmdCompare", ;
		Picture = ..\graphics\compare_13153_32.bmp, ;
		SpecialEffect = 2, ;
		TabIndex = 4, ;
		TabStop = .F., ;
		ToolTipText = "Compare values", ;
		Top = 2, ;
		Width = 56
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'pgfDetails.pgFailuresAndErrors.edtFailuresAndErrors' AS editbox WITH ;
		ControlSource = "", ;
		FontName = "Courier New", ;
		Height = 128, ;
		IntegralHeight = .T., ;
		Left = 4, ;
		Name = "edtFailuresAndErrors", ;
		ReadOnly = .T., ;
		TabIndex = 2, ;
		Top = 3, ;
		Width = 720
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'pgfDetails.pgMessages.edtMessages' AS editbox WITH ;
		ControlSource = "", ;
		FontName = "Courier New", ;
		Height = 128, ;
		IntegralHeight = .T., ;
		Left = 4, ;
		Name = "edtMessages", ;
		ReadOnly = .T., ;
		TabIndex = 3, ;
		Top = 3, ;
		Width = 779
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'Sfsplitterv1' AS sfsplitterv WITH ;
		Anchor = 0, ;
		cobject1name = grdTests, ;
		cobject2name = pgfDetails, ;
		DefWidth = , ;
		Height = 7, ;
		Left = 8, ;
		Name = "Sfsplitterv1", ;
		TabIndex = 16, ;
		Top = 274, ;
		Width = (ThisForm.width-14), ;
		gripper.GripperDot1.Name = "GripperDot1", ;
		gripper.GripperDot1.ShapeDark.Name = "ShapeDark", ;
		gripper.GripperDot1.ShapeLight.Name = "ShapeLight", ;
		gripper.GripperDot1.ShapeMiddle.Name = "ShapeMiddle", ;
		gripper.GripperDot2.Name = "GripperDot2", ;
		gripper.GripperDot2.ShapeDark.Name = "ShapeDark", ;
		gripper.GripperDot2.ShapeLight.Name = "ShapeLight", ;
		gripper.GripperDot2.ShapeMiddle.Name = "ShapeMiddle", ;
		gripper.GripperDot3.Name = "GripperDot3", ;
		gripper.GripperDot3.ShapeDark.Name = "ShapeDark", ;
		gripper.GripperDot3.ShapeLight.Name = "ShapeLight", ;
		gripper.GripperDot3.ShapeMiddle.Name = "ShapeMiddle", ;
		gripper.GripperDot4.Name = "GripperDot4", ;
		gripper.GripperDot4.ShapeDark.Name = "ShapeDark", ;
		gripper.GripperDot4.ShapeLight.Name = "ShapeLight", ;
		gripper.GripperDot4.ShapeMiddle.Name = "ShapeMiddle", ;
		gripper.GripperDot5.Name = "GripperDot5", ;
		gripper.GripperDot5.ShapeDark.Name = "ShapeDark", ;
		gripper.GripperDot5.ShapeLight.Name = "ShapeLight", ;
		gripper.GripperDot5.ShapeMiddle.Name = "ShapeMiddle", ;
		gripper.Name = "gripper"
		*< END OBJECT: ClassLib="sfsplitter.vcx" BaseClass="control" />

	ADD OBJECT 'Shape3' AS shape WITH ;
		Anchor = 8, ;
		Height = 53, ;
		Left = 649, ;
		Name = "Shape3", ;
		SpecialEffect = 0, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'shpButtons' AS shape WITH ;
		Anchor = 10, ;
		BackStyle = 0, ;
		Height = 1, ;
		Left = 0, ;
		Name = "shpButtons", ;
		SpecialEffect = 0, ;
		Top = 52, ;
		Width = 804
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'shpSeparator1' AS shape WITH ;
		Height = 53, ;
		Left = 176, ;
		Name = "shpSeparator1", ;
		SpecialEffect = 0, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'shpSeparator2' AS shape WITH ;
		Height = 53, ;
		Left = 478, ;
		Name = "shpSeparator2", ;
		SpecialEffect = 0, ;
		Top = 0, ;
		Width = 2
		*< END OBJECT: BaseClass="shape" />
	
	PROCEDURE Activate
		IF THIS.ilInitialEntry ;
				AND RECCOUNT(THIS.icGridRS) = 0
		*
		*  on instantiation, if there are no records in
		*  the grid cursor/test results cursor, then
		*  start focus on the <Create New> button
		*
			THIS.cmdCreateNewTestClass.SETFOCUS()
		ENDIF
		
		IF NOT THIS.ilInitialEntry
		*
		*  remove this menu pad (installed in THIS.Deactivate)
		*  any time this form is the active form
		*
			RELEASE PAD pFoxUnit OF _MSYSMENU
		ENDIF
		
		IF THIS.ilInitialEntry
			IF THIS.ilLargeGrid   &&& set in THIS.SettingsRestore()
		*
		*  I couldn't get this to work properly in
		*  THIS.Init
		*
				THIS.ilLargeGrid = .F.
				THIS.toggleGridSize()
			ENDIF
		ENDIF
		
		THIS.ilInitialEntry = .F.
		
		IF TYPE("THIS.ilReloadCurrentClassOnActivate") = "L" ;
				AND THIS.ilReloadCurrentClassOnActivate
		*
		*  FXUResultData::AddNewTest() and ModifyExistingTest()
		*  can set this flag
		*    MODIFY COMMAND FXUResultData
		*
		*	THIS.cmdReloadSelectedTestClass.CLICK()
			ThisForm.ReloadSelectedTestClass()
			
		ENDIF
		
		*% Change per Derek Alweit
		THISFORM.SHOW()
		
	ENDPROC

	PROCEDURE addshortcutoption_classaddtest
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Add a new test (method) to the currently-selected Test Class" ;
		     PICTURE (THIS.cmdAddNewTest.Picture)
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.cmdAddNewTest.Click()
		 
	ENDPROC

	PROCEDURE addshortcutoption_classload
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Load a Test Class (.PRG) that is not already in the list" ;
		     PICTURE (THIS.cmdLoadNewTestClass.Picture)
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.cmdLoadNewTestClass.Click()
		
	ENDPROC

	PROCEDURE addshortcutoption_classnew
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Create a new Test Class (.PRG)" ;
		     PICTURE (THIS.cmdCreateNewTestClass.Picture)
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.cmdCreateNewTestClass.Click()
		
	ENDPROC

	PROCEDURE addshortcutoption_detailsprint
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Print..." 
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.DetailsPrint()
		
	ENDPROC

	PROCEDURE addshortcutoption_detailszoom
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Zoom..." 
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.DetailsZoom()
		
		
	ENDPROC

	PROCEDURE addshortcutoption_formacknowledgements
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Acknowledgements..." ;
		     PICTURE "FXUAcknowledgements.BMP"
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.Acknowledgements()
		
	ENDPROC

	PROCEDURE addshortcutoption_formclose
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Close" ;
		     PICTURE "FXUFormClose.BMP"
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.Release() 
		 
	ENDPROC

	PROCEDURE addshortcutoption_formfont
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Font..." 
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.FormFont()
		
		
	ENDPROC

	PROCEDURE addshortcutoption_formlicense
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "License..." ;
		     PICTURE "FXULicense.BMP"
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.License()
		
	ENDPROC

	PROCEDURE addshortcutoption_formoptions
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Options..." ;
		     PICTURE "FXUOptions.BMP"
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.Options()
		
	ENDPROC

	PROCEDURE addshortcutoption_formresetfont
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Reset Font to default" 
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.FormResetFont()
		
	ENDPROC

	PROCEDURE addshortcutoption_gridresetcolumnwidths
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Reset column widths to default" 
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.GridResetColumnWidths()
		
		
	ENDPROC

	PROCEDURE addshortcutoption_gridsize
		THIS.inBar = ((THIS.inBar/10)+1)*10
		THIS.LockScreen = .t.
		
		IF THIS.ilLargeGrid
		  DEFINE BAR (THIS.inBar) OF pShortCut ;
		       PROMPT "Normal size list"
		 ELSE
		  DEFINE BAR (THIS.inBar) OF pShortCut ;
		       PROMPT "Large size list"
		ENDIF
		
		THIS.LockScreen = .f.
		
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.toggleGridSize()
		
	ENDPROC

	PROCEDURE addshortcutoption_gridsortbylocation
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Sort By Location" 
		IF UPPER(ORDER(THIS.icGridRS)) = UPPER("TCLoc")
		  SET MARK OF BAR THIS.inBar OF pShortCut TO .t.
		ENDIF
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.GridSortByLocation()
		
	ENDPROC

	PROCEDURE addshortcutoption_gridsortbyname
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Sort By Name" 
		IF UPPER(ORDER(THIS.icGridRS)) = UPPER("TCLName")
		  SET MARK OF BAR THIS.inBar OF pShortCut TO .t.
		ENDIF
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.GridSortByName()
		
		
	ENDPROC

	PROCEDURE addshortcutoption_runtestsall
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Run ALL the tests in the list" ;
		     PICTURE (THIS.cmdRunTestsAll.Picture)
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.cmdRunTestsAll.Click()
		
	ENDPROC

	PROCEDURE addshortcutoption_runtestsclass
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Run all the tests in the currently-selected Test Class" ;
		     PICTURE (THIS.cmdRunTestsOneClass.Picture)
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.cmdRunTestsOneClass.Click()
		
	ENDPROC

	PROCEDURE addshortcutoption_runtestselected
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Run only the currently-selected test" ;
		     PICTURE (THIS.cmdRunTestsOne.Picture)
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.cmdRunTestsOne.Click()
		
	ENDPROC

	PROCEDURE addshortcutoption_selectedmodify
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Modify the currently-selected test" ;
		     PICTURE (THIS.cmdModifySelected.Picture)
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.cmdModifySelected.Click()
		
	ENDPROC

	PROCEDURE addshortcutoption_selectedreload
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Reload the Test Class containing the currently-selected test" ;
		     PICTURE (THIS.cmdReloadSelectedTestClass.Picture)
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.cmdReloadSelectedTestClass.Click()
		
	ENDPROC

	PROCEDURE addshortcutoption_selectedremove
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut ;
		     PROMPT "Remove the Test Class containing the currently-selected test" ;
		     PICTURE (THIS.cmdRemoveTestClass.Picture)
		ON SELECTION BAR (THIS.inBar) OF pShortCut _Screen.ActiveForm.cmdRemoveTestClass.Click()
		
	ENDPROC

	PROCEDURE addshortcutoption_separator
		THIS.inBar = ((THIS.inBar/10)+1)*10
		DEFINE BAR (THIS.inBar) OF pShortCut PROMPT "\-"
		
	ENDPROC

	PROCEDURE afterruntests
		LPARAMETERS tlNoGridSetFocus
		
		*
		*  this method is called after each of the "run test(s)"
		*  methods, and several other places
		*
		*  and from THIS.grdTests.AfterRowColChange(), which
		*  passes the tlNoGridSetFocus parameter here as .T. 
		*
		
		IF VARTYPE(tlNoGridSetFocus) != "L"
			tlNoGridSetFocus = .f.
		ENDIF
		IF this.ilTestsFailed AND !tlNoGridSetFocus
			SELECT (this.icGridRs)
			GO TOP 
			LOCATE FOR trun and NOT success and UPPER(TNAME) != "(NONE)"
		ENDIF 
		
		THIS.pgfDetails.pgFailuresAndErrors.edtFailuresAndErrors.Refresh()
		This.pgfDetails.pgFailuresAndErrors.cmdCompare.Refresh()
		THIS.pgfDetails.pgMessages.edtMessages.Refresh()
		
		This.pgfDetails.pgFailuresAndErrors.FontBold = ;
			NOT EMPTY(THIS.pgfDetails.pgFailuresAndErrors.edtFailuresAndErrors.text) 
		This.pgfDetails.pgMessages.FontBold = ;
			NOT EMPTY(THIS.pgfDetails.pgMessages.edtMessages.text) 
		
		THIS.UpdateCurrentGridRowColor()
		
		IF !tlNoGridSetFocus
		  THIS.grdTests.SetFocus()
		ENDIF
		
	ENDPROC

	PROCEDURE applyfilter
		*
		*  this method is called from the LostFocus of
		*  the two filter textboxes above the grid
		*
		IF EMPTY(THIS.icClassFilter) ;
				AND EMPTY(THIS.icNameFilter) ;
				AND NOT THIS.lFailedonly ;
				AND EMPTY(FILTER(THIS.icGridRS))
		*
		*  nothing to do
		*
			RETURN
		ENDIF
		
		LOCAL lcFilter
		m.lcFilter = UPPER(ALLTRIM(THIS.icClassFilter))
		IF NOT EMPTY(m.lcFilter)
			m.lcFilter = ['] + m.lcFilter + [' $ UPPER(TClass)]
		ENDIF
		IF NOT EMPTY(THIS.icNameFilter)
			IF NOT EMPTY(m.lcFilter)
				m.lcFilter = m.lcFilter + " AND "
			ENDIF
			m.lcFilter = m.lcFilter + ['] + UPPER(ALLTRIM(THIS.icNameFilter)) + [' $ UPPER(TName)]
		ENDIF
		IF THIS.lFailedonly
			IF NOT EMPTY(m.lcFilter)
				m.lcFilter = m.lcFilter + " AND "
			ENDIF
			m.lcFilter = m.lcFilter + " not success "
		ENDIF
		
		LOCAL lnSelect
		m.lnSelect = SELECT(0)
		SELECT (THIS.icGridRS)
		
		IF EMPTY(m.lcFilter)
			SET FILTER TO
		ELSE
			SET FILTER TO &lcFilter
			IF NOT EVALUATE(m.lcFilter)
		*
		*  current record does not meet the new
		*  filter condition
		*
				LOCATE
			ENDIF
		ENDIF
		
		THIS.LOCKSCREEN = .T.
		THIS.grdTests.REFRESH()
		*
		*  scroll PageUp, so that if the filter includes more
		*  records above the first/top one showing in the grid,
		*  we can see at least some of them 
		*
		THIS.grdTests.DOSCROLL(2)
		
		This.Refresh()
		THIS.LOCKSCREEN = .F.
	ENDPROC

	PROCEDURE calculaterowcolor		&& Calculates the correct RGB value row color for a test row (grey = not tested, red = falied, green = succeeded)
		LPARAMETERS tlSuccess, tlRun
		
		LOCAL lnRowColor
		DO CASE
		  CASE m.tlRun = .f.
		   	lnRowColor = THIS.inColorNotRun
		  CASE m.tlSuccess = .t.
			lnRowColor = THIS.inColorPass
		  OTHERWISE
		    lnRowColor = THIS.inColorFail
		ENDCASE
		
		RETURN m.lnRowColor
			
				
				
	ENDPROC

	PROCEDURE clearfilter		&& Clear the results filter
		WITH This.cntFilterResults
			.txtClassFilter.Value = SPACE(0)
			.txtNameFilter.Value = SPACE(0)
		ENDWITH
		This.lFailedOnly = .f.
		This.ApplyFilter()
		
		
	ENDPROC

	PROCEDURE Deactivate
		IF NOT USED(THIS.grdTests.RecordSource)
		  *  see THIS.ReceiveResultsNotification()
		  RETURN
		ENDIF
		
		* % This should be an optional setting, but with Thor this is even easier.
		*  install a FoxUnit menu pad whenever this form is
		*  deactivated/minimized, etc.
		*
		*!*	DEFINE PAD pFoxUnit OF _MSYSMENU PROMPT "Fox\<Unit" 
		*!*	ON SELECTION PAD pFoxUnit OF _MSYSMENU FXUShowForm()
		
		
	ENDPROC

	PROCEDURE Destroy
		THIS.SettingsSave(".\FXUPersist.XML")
		
		THIS.ioTestResult = .f.
		THIS.ioTestBroker = .f.
		THIS.ioResultData = .f.
		
	ENDPROC

	PROCEDURE detailsprint
		LOCAL lcSetProc
		lcSetProc = SET("PROCEDURE")
		*
		*  MODIFY COMM FXU
		*
		SET PROCEDURE TO FXU.PRG ADDITIVE 
		
		LOCAL loEditbox
		loEditbox = THIS.ActiveControl
		
		CREATEOBJECT("sesTextBlockReport", ;
		             loEditBox.Text, ;
		             loEditBox.Parent.Caption)
		
		SET PROCEDURE TO &lcSetProc
		
	ENDPROC

	PROCEDURE detailszoom
		*
		*  this method is called from the editbox-level shortcut menu,
		*  and focus could be in either editbox
		*
		
		LOCAL lcSetClassLib, loForm, loEditBox
		lcSetClassLib = SET("CLASSLIB")
		SET CLASSLIB TO FXU 
		
		loEditBox = THIS.ActiveControl
		
		&&	LOCAL loParameter
		&&	loParameter = CREATEOBJECT("Empty")
		&&	ADDPROPERTY(loParameter,"iaCode[1]")
		&&	loParameter.iaCode[1] = "THIS.WindowState = " + TRANSFORM(THIS.inZoomWindowState)
		
		&&	loForm = CREATEOBJECT("frmShowInfo", ;
		&&	                      loEditbox.Text, ;
		&&	                      m.loParameter, ;
		&&	                      loEditBox.Parent.Caption, ;
		&&	                      THIS.inZoomTop, ;
		&&	                      THIS.inZoomLeft, ;
		&&	                      THIS.inZoomHeight, ;
		&&	                      THIS.inZoomWidth, ;
		&&	                      loEditBox.FontName, ;
		&&	                      loEditBox.FontSize, ;
		&&	                      loEditBox.FontBold, ;
		&&	                      loEditBox.FontItalic)
		&&	loForm.Show()          
		MODIFY MEMO (m.loEditBox.ControlSource) NOEDIT NOWAIT WINDOW (thisform.Name)
	ENDPROC

	PROCEDURE execapplication
		*========================================================================================
		* Executes another application
		*========================================================================================
		LParameter tcCmdLine
		
			*--------------------------------------------------------------------------------------
			* API declarations
			*--------------------------------------------------------------------------------------
			DECLARE INTEGER CreateProcess IN kernel32.DLL ;
				String lpApplicationName, ;
				STRING lpCommandLine, ;
				INTEGER lpProcessAttributes, ;
				INTEGER lpThreadAttributes, ;
				INTEGER bInheritHandles, ;
				INTEGER dwCreationFlags, ;
				String lpEnvironment, ;
				String lpCurrentDirectory, ;
				STRING @lpStartupInfo, ;
				STRING @lpProcessInformation
			Declare long GetLastError in Win32API
		
			*--------------------------------------------------------------------------------------
			* Launch the application
			*--------------------------------------------------------------------------------------
			Local lcStartupInfo, lcProcessInfo, lnOK
			lcStartupInfo = ;
				BINTOC(68,"RS") + ;
				Replicate(Chr(0),40) + ;
				BinToC(1,"RS") + ;
				BinToC(10,"2RS") + ; && SW_SHOWDEFAULT
				BinToC(0,"2RS") + ;
				Replicate(Chr(0),16)
			lcProcessInfo = Replicate(Chr(0),16)
			lnOK = CreateProcess( ;
				NULL, ;
				m.tcCmdLine, ;
				0, ;
				0, ;
				1, ;
				0x20, ;
				NULL, ;
				NULL, ;
				@lcStartupInfo, ;
				@lcProcessInfo ;
			)
		
	ENDPROC

	PROCEDURE formatsecondselapsed
		LPARAMETERS tnSecondsElapsed
		
		LOCAL lcFormattedTimeElapsed
		
		lcFormattedTimeElapsed = ;
		     TRANSFORM(INT(tnSecondsElapsed/(60*60))) + ':'  + ;
		     PADL(TRANSFORM(INT(tnSecondsElapsed/60)),2,'0') + ':' + ;
		     PADL(TRANSFORM(MOD(INT(tnSecondsElapsed),60)),2,'0') + '.' +  ;
		     RIGHTC(STR(tnSecondsElapsed,10,3),3)
		     
		RETURN lcFormattedTimeElapsed
	ENDPROC

	PROCEDURE formfont
		*
		*  called from the Form-Level shortcut menu
		*
		
		LOCAL lcFontName, lnFontSize, lcFontStyle, llFontBold, ;
		      llFontItalic, lcNewFont
		lcFontName = THIS.grdTests.FontName
		lnFontSize = THIS.grdTests.FontSize
		lcFontStyle = IIF(THIS.grdTests.FontBold,"B",SPACE(0))
		lcFontStyle = m.lcFontStyle + IIF(THIS.grdTests.FontItalic,"I",SPACE(0))
		
		lcNewFont =  GETFONT(m.lcFontName, lnFontSize, lcFontStyle) 
		
		THIS.Show()
		
		IF EMPTY(m.lcNewFont)
		  RETURN
		ENDIF
		
		THIS.LockScreen = .t.
		
		lcFontName = GETWORDNUM(m.lcNewFont,1,",")
		lnFontSize = INT(VAL(GETWORDNUM(m.lcNewFont,2,",")))
		lcFontStyle = GETWORDNUM(m.lcNewFont,3,",")
		
		llFontBold = "B" $ m.lcFontStyle
		llFontItalic = "I" $ m.lcFontStyle
		
		THIS.grdTests.FontName = m.lcFontName
		THIS.grdTests.FontSize = m.lnFontSize
		THIS.grdTests.FontBold = m.llFontBold
		THIS.grdTests.FontItalic = m.llFontItalic
		
		THIS.pgfDetails.SetAll("FontName",m.lcFontName)
		THIS.pgfDetails.SetAll("FontSize",m.lnFontSize)
		THIS.pgfDetails.SetAll("FontBold",m.llFontBold)
		THIS.pgfDetails.SetAll("FontItalic",m.llFontItalic)
		
		THIS.LockScreen = .f.
		
	ENDPROC

	PROCEDURE formresetfont
		*
		*  this method is called from the form-level shortcut
		*  menu
		*
		
		THIS.LockScreen = .t.
		
		THIS.grdTests.ResetToDefault("FontName")
		THIS.grdTests.ResetToDefault("FontSize")
		THIS.grdTests.ResetToDefault("FontBold")
		THIS.grdTests.ResetToDefault("FontItalic")
		
		LOCAL loPage, loControl
		FOR EACH loPage IN THIS.pgfDetails.Pages
		  loPage.ResetToDefault("FontName")
		  loPage.ResetToDefault("FontSize")
		  loPage.ResetToDefault("FontBold")
		  loPage.ResetToDefault("FontItalic")
		  FOR EACH loControl IN loPage.Controls
		    loControl.ResetToDefault("FontName")
		    loControl.ResetToDefault("FontSize")
		    loControl.ResetToDefault("FontBold")
		    loControl.ResetToDefault("FontItalic")
		  ENDFOR
		ENDFOR
		
		loPage = .NULL.
		loControl = .NULL.
		
		THIS.grdTests.ResetToDefault("FontSize")
		
		THIS.LockScreen = .f.
		
	ENDPROC

	PROCEDURE getfiltertooltiptext
		LOCAL lcText
		
		TEXT TO lcText NOSHOW 
		Filter the list to display only those classes (.PRGs)/tests~
		for which the entered string(s) are contained in the name of~
		the class/test.
		
		For example, to see all tests of Customer code, business~
		objects, etc. enter "Customer" (without the quotes) in the~
		Name filter string textbox.
		
		The string you enter in both filter string textbox is case-~
		insensitive -x the list is filtered where the UPPER() of the~
		filter string(s) is contained in the UPPER() of the class/test~
		names.
		ENDTEXT
		
		m.lcText = CHRTRAN(m.lcText,"~",SPACE(0))
		
		RETURN m.lcText
	ENDPROC

	PROCEDURE gridresetcolumnwidths
		*
		*  this method is called from the grid-level shortcut menu
		*
		
		LOCAL loColumn
		FOR EACH loColumn IN THIS.grdTests.Columns
		  loColumn.ResetToDefault("Width")
		ENDFOR
		
		IF VERSION(5)>=900
		  THIS.grdTests.Resize()
		ENDIF
		
	ENDPROC

	PROCEDURE gridsortbylocation
		IF UPPER(ORDER(THIS.icGridRS)) = UPPER("TCLoc")
		  RETURN
		ENDIF
		
		IF RECCOUNT(THIS.icGridRS) = 0
		  RETURN
		ENDIF
		
		LOCAL lnRecno
		lnRecno = IIF(EOF(THIS.icGridRS),0,RECNO(THIS.icGridRS))
		
		THIS.LockScreen = .t.
		
		SET ORDER TO TAG TCLoc IN (THIS.icGridRS)
		THIS.grdTests.Refresh()
		IF m.lnRecno = 0
		  GO TOP IN (THIS.icGridRS)
		 ELSE
		  GOTO (m.lnRecno) IN (THIS.icGridRS)
		ENDIF
		THIS.grdTests.Refresh()
		
		THIS.LockScreen = .f.
		
		
		
		
	ENDPROC

	PROCEDURE gridsortbyname
		IF UPPER(ORDER(THIS.icGridRS)) = UPPER("TCLName")
		  RETURN
		ENDIF
		
		IF RECCOUNT(THIS.icGridRS) = 0
		  RETURN
		ENDIF
		
		LOCAL lnRecno
		lnRecno = IIF(EOF(THIS.icGridRS),0,RECNO(THIS.icGridRS))
		
		THIS.LockScreen = .t.
		
		SET ORDER TO TAG TCLName IN (THIS.icGridRS)
		THIS.grdTests.Refresh()
		IF m.lnRecno = 0
		  GO TOP IN (THIS.icGridRS)
		 ELSE
		  GOTO (m.lnRecno) IN (THIS.icGridRS)
		ENDIF
		THIS.grdTests.Refresh()
		
		THIS.LockScreen = .f.
		
	ENDPROC

	PROCEDURE Init
		PARAMETERS toTestBroker
		
		IF VARTYPE(m.toTestBroker)!="O" OR ISNULL(m.toTestBroker)
			ERROR 1924, "m.toTestBroker"
			RETURN .F.
		ENDIF
		
		THIS.ioTestBroker =m.toTestBroker
		*THIS.ioFxuInstance=m.toTestBroker.ioFxuInstance
		IF !DODEFAULT(m.toTestBroker.ioFxuInstance)
			RETURN .F.
		ENDIF
		
		LOCAL loFxuInstance AS fxuinstance OF "fxu.vcx"
		m.loFxuInstance=THIS.ioFxuInstance
		m.loFxuInstance.DATASESSIONID=THISFORM.DATASESSIONID
		
		THIS.ioResultData = m.loFxuInstance.FxuNewObject("FXUResultData", m.loFxuInstance, "FXUResults.DBF")
		*
		*  make sure FXUResults.DBF/THIS.icGridRS exists and is
		*  opened
		*    MODIFY COMMAND FXUResultData
		*
		IF NOT VARTYPE(THIS.ioResultData) = "O"
			MESSAGEBOX("Unable to locate/initialize the FXUResults.DBF " + ;
				"FoxUnit results table.", ;
				16, ;
				"Please Note")
			RETURN .F.
		ENDIF
		IF NOT USED("FXUResults")
			MESSAGEBOX("Unable to open the FXUResults.DBF FoxUnit " + ;
				"results table",16,"Please Note")
			RETURN .F.
		ENDIF
		
		*
		*  add the version to THIS.Caption
		*
		THIS.CAPTION = THIS.CAPTION + " - v" + m.loFxuInstance.VERSION
		
		THISFORM.grdTests.INIT()	&&	... again
		THISFORM.pgfDetails.pgMessages.edtMessages.CONTROLSOURCE = THISFORM.icGridRS + ".Messages"
		THISFORM.pgfDetails.PgFailuresAndErrors.edtFailuresAndErrors.CONTROLSOURCE = THISFORM.icGridRS + ".Fail_Error"
		*****
		
		
		THIS.ioTestResult = m.loFxuInstance.FxuNewObject("FxuTestResult")
		
		SET ORDER TO TAG TCLoc IN (THIS.icGridRS)
		
		GO TOP IN (THIS.icGridRS)
		
		IF VERSION(5)>=900
		*
		*  don't permit sizing smaller than the
		*  initial designed size
		*
			THIS.MINHEIGHT = THIS.HEIGHT
			THIS.MINWIDTH = THIS.WIDTH
		ELSE
		*
		*  no Maximize in VFP8 - anchor resizing in VFP9
		*
			THIS.MAXBUTTON = .F.
		*
		*  ditto the ability to resize
		*
			THIS.BORDERSTYLE = 1
		EndIf
		
		*
		*  iaUnprintable array is used for conversions from value to code in 
		*  the SaveProperty method. IsAlpha handles different code pages.
		*
		Local lnAsc, lnCnt
		lnCnt = 0
		For lnAsc = 0 to 255
			If    IsAlpha(Chr(m.lnAsc)) ;
			   or IsDigit(Chr(m.lnAsc)) ;
			   or Chr(m.lnAsc) $ '<>!"§$%&/()=?´*_:;+#-.,{[]}\~' ;
			   or m.lnAsc == Asc("'")
				* printable
			Else
				lnCnt = m.lnCnt + 1
				Dimension This.iaUnprintable[m.lnCnt]
				This.iaUnprintable[m.lnCnt] = m.lnAsc
			EndIf
		EndFor 
		
		*
		*  apply settings saved last time in THIS.SettingsSave(),
		*  called from THIS.Destroy()
		*
		
		THIS.SettingsRestore(".\FXUPersist.XML")
		
		*
		*  THIS.inColorNotRun is now ignored -- I've set it
		*  to match the default/normal color
		*
		THIS.inColorNotRun = THIS.grdTests.BACKCOLOR
		
		THIS.UpdateCurrentGridRowColor()
		
		THIS.SHOW() && Matt Slay 2013-12-17
		THISFORM.sfsplitterv1.MoveSplitterToPosition(THIS.nSplitterPosition) && Matt Slay 2013-12-17
		This.Resize()
		
		THIS.LOCKSCREEN = .F.
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		*
		*  we only get here when focus is in THIS.grdTests --
		*  see its When and Valid
		*
		
		IF m.nKeyCode = 4
		    *
		    *  THIS.grdTests.Columns exactly fill the available 
		    *  grid width, and therefore we're suppressing this 
		    *  {RightArrow} keystroke, which would otherwise 
		    *  undesirably scroll the grid leftward
		    *
		    *  note that grdBase::When() and grdBase::Valid() 
		    *  have code to only set THIS.KeyPreview to .T. when
		    *  the grid has focus, so that this method does
		    *  not fire in normal scenarios
		    *
		    NODEFAULT
		    *
		    *  and now we'll call the grid.KeyPress() manually,
		    *  so that any RightArrow-specific code still fires
		    *  (the above NODEFAULT suppresses the native VFP
		    *  Grid.KeyPress method from firing) -- note that
		    *  this code calls the Grid.KeyPress() method, but
		    *  DOES NOT fire the Grid.KeyPress EVENT
		    *
		    THIS.grdTests.KeyPress(4,m.nShiftAltCtrl)
		ENDIF
		
		
		IF m.nShiftAltCtrl = 2 AND INLIST(m.nKeyCode,30,31)
		  *
		  *  nShiftAltCtrl = 2/CTRL
		  *  nKeyCode = 30/PgDn
		  *  nKeyCode = 31/PgUp
		  *
		  IF m.nKeyCode = 30
		    THIS.MoveToFirstTestOfNextClass(.t.)
		   ELSE
		    THIS.MoveToFirstTestOfNextClass(.f.)
		  ENDIF
		ENDIF
		
		IF m.nShiftAltCtrl = 2 AND m.nKeyCode = 19
		  *
		  *  CTRL+s
		  *
		  THIS.toggleGridSize()
		ENDIF
	ENDPROC

	PROCEDURE Load
		IF UPPER(JUSTSTEM(SYS(16,0))) == "FXU" ;
		     OR UPPER(PROGRAM(PROGRAM(-1)-2)) == "FXU" ;
		     OR UPPER(PROGRAM(PROGRAM(-1)-3)) == "FXU"
		  *
		  *  FoxUnit started via DO FXU or by a menu 
		  *  option that issues DO FXU
		  *     
		 ELSE
		  MESSAGEBOX("The FoxUnit form interface is designed to be " + ;
		             "called from the FXU.PRG -- please start the " + ;
		             "FoxUnit form interface by:" + CHR(13) + CHR(13) + ;
		             "  DO FXU", ;
		             48, ;
		             "Please Note")
		  *KEYBOARD "DO FXU " PLAIN CLEAR 
		  *ACTIVATE WINDOW Command 
		  RETURN .f.
		ENDIF             
		
		*
		*  SET commands scoped to private data sessions
		*
		SET CENTURY ON
		SET DELETED ON
		SET SAFETY OFF 
		SET EXCLUSIVE OFF
		SET MULTILOCKS ON
		SET NOTIFY OFF
		SET SAFETY OFF 
		SET TALK OFF 
		
		*
		*  save these for use in THIS.SettingsSave()
		*
		THIS.AddProperty("inDesignHeight",THIS.Height)
		THIS.AddProperty("inDesignWidth",THIS.Width)
		
		*
		*  other setup tasks
		*
		
		*THIS.Icon = "FoxUnit.Ico"
		
		THIS.LockScreen = .t.
		
	ENDPROC

	PROCEDURE modifyclassatlinenumber
		LPARAMETERS tnLineNumber
		
		EDITSOURCE(FORCEEXT(ALLTRIM(EVALUATE(THIS.icGridRS+".TClass")),"PRG"),m.tnLineNumber)
		
		THIS.AddProperty("ilReloadCurrentClassOnActivate",.t.)
	ENDPROC

	PROCEDURE movetofirsttestofnextclass
		*
		*  DEVNOTE
		*
		*  lParameters
		*    tlNext (R) .T. = Next/.F. = Previous
		*
		LPARAMETERS tlNext
		
		IF RECCOUNT(THIS.icGridRS) = 0
		  RETURN
		ENDIF
		
		LOCAL lcClassName, lnSelect, lcTag
		lnSelect = SELECT(0)
		SELECT (THIS.icGridRS)
		lcClassName = TClass
		lcTag = ORDER()
		
		IF NOT m.tlNext
		  SET ORDER TO TAG (m.lcTag) DESCENDING
		ENDIF
		
		THIS.LockScreen = .t.
		
		LOCATE REST FOR NOT UPPER(TClass) == UPPER(m.lcClassName) ;
		    AND Location = 1
		
		IF EOF()
		  *
		  *  cycle around to the first/top or last/bottom
		  *
		  LOCATE
		ENDIF
		
		SET ORDER TO TAG (m.lcTag) ASCENDING
		
		THIS.grdTests.Refresh()
		
		SELECT (m.lnSelect)
		
		THIS.LockScreen = .f.
		
		
	ENDPROC

	PROCEDURE onsettingssave
		PARAMETERS tcAlias
		
		IF VARTYPE(m.tcAlias)!="C" OR !USED(m.tcAlias)
			RETURN .F.
		ENDIF
		
		Local loPersistVariables
		SELECT (m.tcAlias)
		SCATTER NAME loPersistVariables MEMO
		loPersistVariables.UserID = THIS.ioFxuInstance.UserId
		
		loPersistVariables.Setting = "THIS.Top = " + TRANSFORM(THIS.Top)
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		loPersistVariables.Setting = "THIS.Left = " + TRANSFORM(THIS.Left) 
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		loPersistVariables.Setting = "THIS.Height = IIF(VERSION(5)>=900," + TRANSFORM(THIS.Height) + "," + TRANSFORM(THIS.inDesignHeight) + ")"
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		loPersistVariables.Setting = "THIS.Width = IIF(VERSION(5)>=900," + TRANSFORM(THIS.Width) + "," + TRANSFORM(THIS.inDesignWidth) + ")"
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		
		loPersistVariables.Setting = "THIS.inZoomTop = " + TRANSFORM(THIS.inZoomTop) 
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		loPersistVariables.Setting = "THIS.inZoomLeft = " + TRANSFORM(THIS.inZoomLeft) 
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		loPersistVariables.Setting = "THIS.inZoomHeight = " + TRANSFORM(THIS.inZoomHeight) 
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		loPersistVariables.Setting = "THIS.inZoomWidth = " + TRANSFORM(THIS.inZoomWidth) 
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		loPersistVariables.Setting = "THIS.inZoomWindowState = " + TRANSFORM(THIS.inZoomWindowState) 
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		
		loPersistVariables.Setting = "THIS.pgfDetails.ActivePage = " + TRANSFORM(THIS.pgfDetails.ActivePage)
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		
		*
		*  font settings
		*
		loPersistVariables.Setting = [THIS.grdTests.FontName = "] + TRANSFORM(THIS.grdTests.FontName) + ["]
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		loPersistVariables.Setting = "THIS.grdTests.FontSize = " + TRANSFORM(THIS.grdTests.FontSize)
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		loPersistVariables.Setting = "THIS.grdTests.FontBold = " + TRANSFORM(THIS.grdTests.FontBold)
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		loPersistVariables.Setting = "THIS.grdTests.FontItalic = " + TRANSFORM(THIS.grdTests.FontItalic)
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		LOCAL loPage, loControl
		FOR EACH loPage IN THIS.pgfDetails.Pages
		  loPersistVariables.Setting = [THIS.pgfDetails.] + loPage.Name + [.FontName = "] + TRANSFORM(loPage.FontName) + ["]
		  INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		  loPersistVariables.Setting = "THIS.pgfDetails." + loPage.Name + ".FontSize = " + TRANSFORM(loPage.FontSize)
		  INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		  loPersistVariables.Setting = "THIS.pgfDetails." + loPage.Name + ".FontBold = " + TRANSFORM(loPage.FontBold)
		  INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		  loPersistVariables.Setting = "THIS.pgfDetails." + loPage.Name + ".FontItalic = " + TRANSFORM(loPage.FontItalic)
		  INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		  FOR EACH loControl IN loPage.Controls
		    loPersistVariables.Setting = [THIS.pgfDetails.] + loPage.Name + "." + loControl.Name + [.FontName = "] + TRANSFORM(loControl.FontName) + ["]
		    INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		    loPersistVariables.Setting = "THIS.pgfDetails." + loPage.Name + "." + loControl.Name + ".FontSize = " + TRANSFORM(loControl.FontSize)
		    INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		    loPersistVariables.Setting = "THIS.pgfDetails." + loPage.Name + "." + loControl.Name + ".FontBold = " + TRANSFORM(loControl.FontBold)
		    INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		    loPersistVariables.Setting = "THIS.pgfDetails." + loPage.Name + "." + loControl.Name + ".FontItalic = " + TRANSFORM(loControl.FontItalic)
		    INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		  ENDFOR    
		ENDFOR
		loPage = .NULL.
		loControl = .NULL.
		
		*
		*  grid.Height
		*
		loPersistVariables.Setting = "THIS.ilLargeGrid=" + TRANSFORM(THIS.ilLargeGrid) 
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		
		*
		*  each grid.Column.Width
		*
		LOCAL loColumn
		FOR EACH loColumn IN THIS.grdTests.Columns
		  loPersistVariables.Setting = ;
		       "THIS.grdTests." + loColumn.Name + ".Width = " + ;
		       TRANSFORM(loColumn.Width)  
		  INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		ENDFOR
		
		*
		*  indeg tag for the grid cursor
		*
		loPersistVariables.Setting = "SET ORDER TO TAG " + ORDER(THIS.icGridRS) + " IN (THIS.icGridRS)"
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		
		*
		*  record pointer in the grid
		*
		loPersistVariables.Setting = [=SEEK("] + ;
		             UPPER(EVALUATE(THIS.icGridRS+".TClass")) + ;
		             UPPER(EVALUATE(THIS.icGridRS+".TName")) + ;
		            [",THIS.icGridRS,"TCLName")]
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		
		
		*********************************************************
		*
		*  Options... settings
		*
		*********************************************************
		loPersistVariables.Setting = "THIS.ilAllowDebug = " + TRANSFORM(THIS.ilAllowDebug)
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		
		loPersistVariables.Setting = "THIS.ShowTips = " + TRANSFORM(THIS.ShowTips)
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		
		loPersistVariables.Setting = "THIS.ilHonorTestPrefix = " + TRANSFORM(this.ilHonorTestPrefix)
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		
		loPersistVariables.Setting = "THIS.ilReloadTestsOnRun = " + TRANSFORM(THIS.ilReloadTestsOnRun)
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables 
		
		loPersistVariables.Setting = "THIS.ilCloseDebuggerAtEndOfTestsRun = " + TRANSFORM(THIS.ilCloseDebuggerAtEndOfTestsRun)
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables
		
		loPersistVariables.Setting = "THIS.nSplitterPosition = " + TRANSFORM(THIS.sfsplitterv1.Top)
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables
		
		*EJS New setting to reset results 5/15/2015
		loPersistVariables.Setting = "THIS.iResetResults = " + TRANSFORM(This.iResetResults)
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables
		
		*EJS New settings for pass/fail color 8/27/2016
		loPersistVariables.Setting = "THIS.inColorPass = " + TRANSFORM(This.inColorPass)
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables
		loPersistVariables.Setting = "THIS.inColorFail = " + TRANSFORM(This.inColorFail)
		INSERT INTO (m.tcAlias) FROM NAME loPersistVariables
		
		*CW New settings for comparision tool
		This.SaveProperty ("icCompareTool", m.loPersistVariables, m.tcAlias)
		This.SaveProperty ("icCompareParameters", m.loPersistVariables, m.tcAlias)
		
	ENDPROC

	PROCEDURE options
		*
		*  this method is called from the form-level shortcut menu
		*
		
		LOCAL loForm
		loForm = thisform.iofxuinstance.FxuNewObject("FXUOptionsDialog")
		loForm.Show()
	ENDPROC

	PROCEDURE receivecompletenotification
		LPARAMETERS tnTestCount, tnFailedTests, tnSuiteSuccess, tnSecondsElapsed
		
		SET DATASESSION TO thisform.iofxuinstance.datasessionid
		
		IF NOT USED(THIS.grdTests.RecordSource)
		  *  see THIS.ReceiveResultsNotification()
		  RETURN
		ENDIF
		
		This.setTestsRunTestsFailedLabel(tnTestcount, tnFailedTests, this.FormatSecondsElapsed(tnSecondsElapsed))
		
		* Added so that when we run frmFxuFoxUnit::AfterRunTests() we can
		* seek the first failed test in the run and set the focus on that row
		* showing the failure and/or exception immediately for feedback
		this.ilTestsFailed = (tnFailedTests > 0)
		
		THISFORM.grdTests.Refresh()
		THISFORM.pgfDetails.pgFailuresAndErrors.edtFailuresAndErrors.Refresh()
		*THISFORM.edtFailuresAndErrors.Refresh()
		THISFORM.pgfDetails.pgMessages.edtMessages.Refresh()
		*THISFORM.edtMessages.Refresh()
		
		
		SELECT (THIS.grdTests.RecordSource)
		iRun = 0
		iSuccess = 0
		SCAN FOR TRun
			iRun = iRun + 1 
			IF Success
				iSuccess = iSuccess + 1 
			ENDIF 
		ENDSCAN
		This.lblAllResults.Caption = "All Tests: ("+TRANSFORM(iSuccess)+" / " + TRANSFORM(iRun)+")"
	ENDPROC

	PROCEDURE receiveresultnotification		&& Recieves results of the current test
		LPARAMETERS toTestResult as FxuTestResult of FxuTestResult.prg
		
		SET DATASESSION TO thisform.iofxuinstance.datasessionid
		
		IF NOT USED(THIS.grdTests.RecordSource)
		TEXT TO lcText NOSHOW PRETEXT 3 FLAGS 1
		The FXUResults.DBF table drives the grid in the FoxUnit form interface AND logs Failure/Error/Message results.
		
		HOWEVER, the FXUResults table has been CLOSED sometime during the execution of your last test!  
		Most likely, you have some code in the TearDown method that closes work areas indiscriminately 
		or otherwise issues command(s) like CLEAR ALL/CLOSE ALL/etc.
		
		You need to determine where/when/why you are closing the FXUResults.DBF table during the execution of your test(s), 
		and rememdy that behavior.
		
		In the meantime, the FoxUnit test harness has to shutdown because the grid.RecordSource cannot be 'restored' once 
		it has been closed.
		ENDTEXT
		
		  MESSAGEBOX(m.lcText,16,"FXUResults.DBF table is closed!")
		  THISFORM.Release()
		  RETURN 
		ENDIF
		
		LOCAL loResultDAta as FxuResultData OF FxuResultData.prg
		
		loResultData = THIS.ioResultData
		
		loResultData.LogResult(toTestResult)
		
		
		THIS.ShowProgress(toTestResult.inRunTests, toTestResult.ilCurrentResult)
		=SEEK(UPPER(ALLTRIM(toTestResult.icCurrentTeSTCLASS)) + UPPER(ALLTRIM(toTestREsult.icCurrentTestName)),THIS.icGridRS,'tclname')
		
		THIS.Refresh()
	ENDPROC

	PROCEDURE reloadselectedtestclass
		
		This.ioResultData.ReloadTestCaseClass(EVALUATE(This.icGridRS+".TCLass"), EVALUATE(This.icGridRS+".TPath") )
		This.AfterRunTests()
		This.Refresh()
		
	ENDPROC

	PROCEDURE Resize
		IF DODEFAULT()
			IF THIS.ilLargeGrid
				THIS.grdTests.HEIGHT = ThisForm.Height - THIS.grdTests.Top - ThisForm.pbProgress.Height - 30
			ENDIF
		ENDIF 
		
	ENDPROC

	PROCEDURE RightClick
		IF THIS.ShortcutMenuForm()
		  ACTIVATE POPUP pShortCut
		ENDIF
		
		    
		
		
	ENDPROC

	PROCEDURE runalltests		&& runs all tests in all test classes that are currently loaded into the thisform.icGridRs table
		LOCAL lcTestClass, lcTestMethod, lcPath  && Added path. HAS
		
		*
		*  scroll the grid to the top
		*
		IF THISFORM.ilReloadTestsOnRun
			THIS.ioResultData.ReloadTestCaseClasses()
		ENDIF
		
		SELECT (THIS.icGridRS)
		LOCATE
		THIS.grdTests.REFRESH()
		
		* Select the test class and test name for all tests currently
		* loaded into the result table, ordered by class name and test name
		* into a cursor to be added into the testsuite
		*	SELECT TClass, TName FROM (THIS.icGridRS)  ;
		*		ORDER BY TClass, TName ;
		*		INTO CURSOR Curs_TestSuite
		
		* Declare and Insantiate TestSuite
		LOCAL loTestSuite AS FxuTestSuite OF FxuTestSuite.prg
		loTestSuite = THISFORM.iofxuinstance.FxuNewObject("FxuTestSuite", THISFORM.iofxuinstance)
		loTestSuite.ilAllowDebug = THISFORM.ilAllowDebug
		
		* Load the tests into the testsuite
		SELECT (THIS.icGridRS)
		GO TOP
		
		SCAN
			lcTestClass = ALLTRIM(tclass)
			lcTestMethod = ALLTRIM(tname)
			lcPath = ADDBS(tpath) && Added path. HAS
			IF NOT THIS.SeeIfTestClassPRGExists(lcPath + m.lcTestClass) && Added path. HAS
		*
		*  skip the rest of the tests in this missing test class
		*
				SCAN WHILE ALLTRIM(tclass) == m.lcTestClass
				ENDSCAN
				IF NOT EOF()
		*
		*  go back one record, because there is an
		*  implicit SKIP in the ENDSCAN
		*
					SKIP -1
				ENDIF
			ELSE
				loTestSuite.AddTest(lcPath + lcTestClass, lcTestMethod) && Added path. HAS
			ENDIF
		ENDSCAN
		
		* Assign the result object to the TestSuite
		loTestSuite.ioTestResult = THIS.ioTestResult
		
		* Bind Events to the results events in the TestSuite
		BINDEVENT(loTestSuite,'Event_OneTestComplete',THISFORM,'Receiveresultnotification')
		BINDEVENT(loTestSuite,'Event_AllTestsComplete',THISFORM,'ReceiveCompleteNotification')
		
		* Set the progress of this form to it's initial values for running
		* this TestSuite
		THIS.SetProgress(loTestSuite.inTestCount)
		
		* Run all of the tests in the TestSuite
		loTestSuite.RunTests()
		
		UNBINDEVENTS(loTestSuite)
		
		IF THISFORM.ilCloseDebuggerAtEndOfTestsRun
			CLOSE DEBUGGER
		ENDIF
		
		SELECT (THIS.icGridRS)
		LOCATE
		
		THIS.AfterRunTests()
		
		
	ENDPROC

	PROCEDURE runclasstests		&& Runs all tests for the class specified
		LPARAMETERS tcTestClass && name of class who's tests we will run
		
		LOCAL lcTClass, lcTPath  && Added path. HAS
		lcTClass = UPPER(EVALUATE(THIS.icGridRS+".TClass"))
		lcTPath = EVALUATE(THISFORM.icGridRS+".TPath") && Added path. HAS
		
		IF NOT THIS.SeeIfTestClassPRGExists(ADDBS(lcTPath) + m.lcTClass) && Added path. HAS
		  RETURN
		ELSE
			IF this.ilReloadTestsOnRun
				this.ioResultData.ReloadTestCaseClass(m.lcTClass, m.lcTPath) && Added path. HAS
				LOCATE FOR UPPER(tclass) = lcTClass
			ENDIF 
		ENDIF
		
		* Select all test names from the THIS.icGridRS table that
		* belong to the test class passed
		*	SELECT tname FROM (THIS.icGridRS) WHERE tclass == tcTestClass ;
		*		ORDER BY tname ;
		*		INTO CURSOR Curs_TestSuite
			
		tcTestClass = ALLTRIM(tcTestClass)
		
		* Declare and Insantiate TestSuite
		LOCAL loTestSuite as FxuTestSuite OF FxuTestSuite.prg
		loTestSuite = thisform.iofxuinstance.FxuNewObject("FxuTestSuite", thisform.ioFxuInstance)
		loTestSuite.ilAllowDebug = thisform.IlAllowDebug
		
		* Load the tests into the testsuite
		* SELECT Curs_TestSuite
		
		SELECT (this.icGridRs)
		GO top
		
		SCAN FOR UPPER(ALLTRIM(tclass)) == UPPER(ALLTRIM(tcTestClass))
			loTestSuite.AddTest(ADDBS(lcTPath) + tcTestClass, ALLTRIM(tname)) && Added path. HAS
		ENDSCAN
		
		* Assign the result object to the TestSuite
		loTestSuite.ioTestResult = thisform.ioTestResult
		
		* Bind Events to the results events in the TestSuite
		BINDEVENT(loTestSuite,'Event_OneTestComplete',Thisform,'Receiveresultnotification')
		BINDEVENT(loTestSuite,'Event_AllTestsComplete',ThisForm,'ReceiveCompleteNotification')
		
		
		* Set the progress of this form to it's initial values for running
		* this TestSuite
		ThisForm.SetProgress(loTestSuite.inTestCount)
		
		* Run all of the tests in the TestSuite
		loTestSuite.RunTests()
		
		UNBINDEVENTS(loTestSuite)
		
		IF thisform.ilCloseDebuggerAtEndOfTestsRun
			CLOSE DEBUGGER 
		ENDIF 
		
		
		SELECT (THIS.icGridRS)
		*
		*  reposition the record pointer on the first
		*  test for the class 
		*
		LOCATE FOR UPPER(TClass) == m.lcTClass
		
		THIS.AfterRunTests()
	ENDPROC

	PROCEDURE runonetest		&& Runs the one test who's row is currently selected in the grid
		LPARAMETERS tcTestClass, tcTestMethod, tcPath && Added path parameter. HAS
		
		SELECT (THIS.icGridRS)
		LOCAL lcTClass, lcTName, lcTPath && Added path. HAS
		lcTClass = UPPER(EVALUATE(THIS.icGridRS+".TClass"))
		lcTName = UPPER(EVALUATE(THIS.icGridRS+".TName"))
		lcTPath = UPPER(EVALUATE(THIS.icGridRS+".TPath")) && HAS
		
		IF NOT THIS.SeeIfTestClassPRGExists(ADDBS(lcTPath) + m.lcTClass) && Added path. HAS
		  RETURN
		ENDIF
		
		* Declare and Insantiate TestSuite
		LOCAL loTestSuite as FxuTestSuite OF FxuTestSuite.prg
		loTestSuite = thisform.iofxuinstance.FxuNewObject("FxuTestSuite", thisform.ioFxuInstance)
		loTestSuite.ilAllowDebug = thisform.IlAllowDebug
		
		* Add this one test to the test suite
		loTestSuite.AddTest(ADDBS(m.lcTPath) + tcTestClass,tcTestMethod) && Added path. HAS
		
		* Assign the result object to the TestSuite
		loTestSuite.ioTestResult = thisform.ioTestResult
		
		* Bind Events to the results events in the TestSuite
		BINDEVENT(loTestSuite,'Event_OneTestComplete',Thisform,'Receiveresultnotification')
		BINDEVENT(loTestSuite,'Event_AllTestsComplete',ThisForm,'ReceiveCompleteNotification')
		
		* Set the progress of this form to it's initial values for running
		* this TestSuite
		ThisForm.SetProgress(loTestSuite.inTestCount)
		
		* Run all of the tests in the TestSuite
		loTestSuite.RunTests()
		
		UNBINDEVENTS(loTestSuite)
		
		IF thisform.ilCloseDebuggerAtEndOfTestsRun
			CLOSE DEBUGGER 
		ENDIF 
		
		
		IF NOT USED(THIS.grdTests.RecordSource)
		  *  see THIS.ReceiveResultsNotification()
		  RETURN
		ENDIF
		
		* JDE 03/14/2005 Added to replace code originally below
		* This.AfterRunTests() to resolve defect of last test
		* not being reselected and being the grid's (windows)
		* selected color rather than green as reported
		* in an internal defect report at Visionpace
		LOCATE FOR UPPER(TClass) == m.lcTClass AND UPPER(TName) == m.lcTName 
		
		THIS.AfterRunTests()
		
		*  when running one test, always return to
		*  that test
		* commented out as per comment above locate statement
		*SELECT (THIS.icGridRS)
		*=SEEK(m.lcTClass+m.lcTName,THIS.icGridRS,"TCLName")
		
	ENDPROC

	PROCEDURE saveproperty
		*========================================================================================
		* Saves a single property value into the settings table
		*========================================================================================
		LParameter tcProperty, toPersistVariables, tcAlias
		
			*--------------------------------------------------------------------------------------
			* Assertions
			*--------------------------------------------------------------------------------------
			Assert Vartype(m.tcProperty) == "C"
			Assert PemStatus(This, m.tcProperty, 5)
			Assert Vartype(m.toPersistVariables) == "O"
			Assert Used(m.tcAlias)
			
			*--------------------------------------------------------------------------------------
			* Convert property value to FoxPro source code as a string that is safe for execution.
			*--------------------------------------------------------------------------------------
			Local luValue, lcCode
			luValue = GetPem(This, m.tcProperty)
			Do case
			Case Vartype(m.luValue) == "X"
				lcCode = ".NULL."
			Case Vartype(m.luValue) == "N"
				Assert m.luValue == Round(m.luValue, 0) Message ;
					"Only integer values are supported. Fractions need to handle SET POINT " + ;
					"and SET DECIMAL correctly."
				lcCode = TRANSFORM(m.luValue)
			Case Vartype(m.luValue) == "C"
				Local lnBlock, lcBlock, lnAsc
				lcCode = ""
				For lnBlock = 1 to Ceiling(Len(m.luValue)/250) && String literals limited
					If not Empty(m.lcCode)
						lcCode = m.lcCode + "+"
					EndIf
					lcBlock = Substr(m.luValue, (m.lnBlock-1)*250+1, 250)
					lcBlock = Strtran (m.lcBlock, "'", "'+Chr("+Transform(Asc("'"))+")+'")
					For each lnAsc in This.iaUnprintable
						If Chr(lnAsc) $ m.lcBlock
							lcBlock = Strtran (m.lcBlock, Chr(m.lnAsc), "'+Chr("+Transform(m.lnAsc)+")+'")
						EndIf
					EndFor 
					lcCode = m.lcCode + "'" + m.lcBlock + "'"
				EndFor 
			Otherwise
				Assert .F. Message "Unhandled data type '"+Vartype(m.luValue)+"'"
				Return
			EndCase
			
			*--------------------------------------------------------------------------------------
			* Save code line into settings table.
			*--------------------------------------------------------------------------------------
			toPersistVariables.Setting = "THIS." + m.tcProperty + " = " + m.lcCode
			INSERT INTO (m.tcAlias) FROM NAME toPersistVariables
		
	ENDPROC

	PROCEDURE seeiftestclassprgexists
		LPARAMETERS tcTClass
		
		IF NOT FILE(FORCEEXT(ALLTRIM(m.tcTClass),"PRG"))
		  MESSAGEBOX("Unable to locate " + FORCEEXT(ALLTRIM(m.tcTClass),"PRG") + ", " + ;
		             "likely because it has been moved, erased, or renamed." + ;
		             CHR(13) + CHR(13) + ;
		             "You should likely remove it from the list, " + ;
		             "by selecting any of its tests and then clicking " + ;
		             "the <Remove Selected> button.", ;
		             16, ;
		             "Please Note")
		  RETURN .f.
		ENDIF             
		
		RETURN .t.
		
	ENDPROC

	PROCEDURE setallowdebug
		LPARAMETERS tnAllowDebug
		
		IF tnAllowDebug = 1
			thisform.ilAllowDebug = .t.
		ELSE
			thisform.ilAllowDebug = .f.
		ENDIF
		
	ENDPROC

	PROCEDURE setprogress		&& sets progress bar back to no tests run status
		LPARAMETERS tnMaxValue
		
		*% EJS
		UPDATE (THIS.icGridRS) SET trun = (! ThisForm.iResetResults)
		
		
		thisform.pbProgress.SetRange(0,tnMaxValue)
		thisform.pbProgress.SetValue(0)
		
		
		thisform.pbProgress.shpbar.BackColor = thisform.inColorPass
		thisform.pbProgress.Refresh
	ENDPROC

	PROCEDURE settestsruntestsfailedlabel
		LPARAMETERS tnTestsRun, tnTestsFailed, tcTimeElapsed
		
		LOCAL lcTestsRun, lcTestsFailed, lcMessage, lcTestsPassed
		
		
		
		lcTestsRun = ALLTRIM(TRANSFORM(tnTestsRun, '999,999'))
		lcTestsFailed = ALLTRIM(TRANSFORM(tnTestsFailed, '999,999'))
		lcTestsPassed = ALLTRIM(TRANSFORM(tnTestsRun - tnTestsFailed, '999,999'))
		
		lcMessage = ;
		        lcTestsRun + ;
		        IIF(tnTestsRun <> 1, ' tests were run.  ', ' test was run.  ') + ;
		        lcTestsPassed + ;
		        IIF((tnTestsRun - tnTestsFailed) <> 1, ' tests passed.  ', ' test passed.  ') + ;
		        lcTestsFailed + ;
		        IIF(tnTestsFailed <> 1, ' tests failed.  ', ' test failed.  ')
		
		IF NOT EMPTY(tcTimeElapsed)
		        lcMessage = lcMessage + 'Elapsed Time: ' + tcTimeElapsed
		ENDIF
		
		THISFORM.lblTestsRunTestsFailed.CAPTION = lcMessage
		
		RETURN
		
		
	ENDPROC

	PROCEDURE shellshortcutmenueditbox
		*
		*  this is a shell method called from THIS.ShortcutMenuEditbox()
		*  ... adjust the editbox-level shortcut menu as you wish...
		*
	ENDPROC

	PROCEDURE shellshortcutmenuform
		*
		*  this is a shell method called from THIS.ShortcutMenuForm()
		*  ... adjust the form-level shortcut menu as you wish...
		*
	ENDPROC

	PROCEDURE shellshortcutmenugrid
		*
		*  this is a shell method called from THIS.ShortcutMenuGrid()
		*  ... adjust the grid-level shortcut menu as you wish...
		*
	ENDPROC

	PROCEDURE shortcutmenueditbox
		*
		*  called the 2 editboxes on the pageframe, this separate 
		*  method allows subclassing this method and modifying 
		*  the shortcut menu before THIS.RightClick() issues
		*  the ACTIVATE POPUP
		*
		*  or, you can adjust items by augmenting/overriding
		*  the individual methods where shortcut options
		*  are added
		*
		*  and, you can adjust the menu in THIS.ShellShortcutMenuForm(),
		*  called here before the final option is added to the
		*  shortcut menu
		*  
		
		LPARAMETERS toControl
		
		DEFINE POPUP pShortCut IN WINDOW (THIS.Name) SHORTCUT RELATIVE FROM MROW(THIS.Name),MCOL(THIS.Name)
		
		IF UPPER(toControl.Name) = UPPER("edtFailuresAndErrors")
		  *
		  *  find the first line that contains a line
		  *  containing 
		  *  "line nnn of" 
		  *
		  LOCAL laLines[1], xx, lcLine, lnLine, lcLineNumber, lcOnSel, ;
		        lcOF
		  lcOF = " OF " + UPPER(ALLTRIM(EVALUATE(THIS.icGridRS+".TName")))
		  lnLine = 0
		  ALINES(laLines,toControl.Value)
		  FOR xx = 1 TO ALEN(laLines,1)
		    lcLine = UPPER(laLines[m.xx])
		    IF " LINE " $ m.lcLine ;
		         AND m.lcOF $ m.lcLine ;
		         AND AT_C(m.lcOF,m.lcLine) > AT_C(" LINE ",m.lcLine)
		      lnLine = m.xx
		      EXIT
		    ENDIF
		  ENDFOR
		  IF m.lnLine > 0
		    lcLine = ALLTRIM(SUBSTRC(m.lcLine,AT_C(" LINE ",m.lcLine)))
		    IF RIGHTC(m.lcLine,1) = "."
		      lcLine = LEFTC(m.lcLine,LENC(m.lcLine)-1)
		    ENDIF
		    lcLineNumber = GETWORDNUM(m.lcLine,2,SPACE(1))
		    DEFINE BAR 1 OF pShortcut PROMPT "Edit " + m.lcLine 
		    lcOnSel = "ON SELECTION BAR 1 OF pShortCut _Screen.ActiveForm.ModifyClassAtLineNumber(" + m.lcLineNumber + ")"
		    &lcOnSel
		    DEFINE BAR 2 OF pShortcut PROMPT "\-"
		  ENDIF  
		ENDIF
		
		THIS.inBar = 10
		
		THIS.AddShortcutOption_FormFont()
		THIS.AddShortcutOption_FormResetfont()
		THIS.AddShortcutOption_Separator
		
		THIS.AddShortcutOption_DetailsPrint()
		THIS.AddShortcutOption_DetailsZoom()
		
		THIS.ShellShortcutMenuEditbox()
		
		
	ENDPROC

	PROCEDURE shortcutmenuform
		*
		*  called from THIS.RightClick(), this separate method
		*  allows subclassing this method and modifying 
		*  the shortcut menu before THIS.RightClick() issues
		*  the ACTIVATE POPUP
		*
		*  or, you can adjust items by augmenting/overriding
		*  the individual methods where shortcut options
		*  are added
		*
		*  and, you can adjust the menu in THIS.ShellShortcutMenuForm(),
		*  called here before the final option is added to the
		*  shortcut menu
		*  
		
		THIS.inBar = 10
		
		DEFINE POPUP pShortCut IN WINDOW (THIS.Name) SHORTCUT RELATIVE FROM MROW(THIS.Name),MCOL(THIS.Name)
		
		*!*	THIS.AddShortcutOption_RunTestsAll()
		*!*	THIS.AddShortcutOption_RunTestsClass()
		*!*	THIS.AddShortcutOption_RunTestSelected()
		*!*	THIS.AddShortcutOption_Separator()
		
		*!*	THIS.AddShortcutOption_ClassNew()
		*!*	THIS.AddShortcutOption_ClassLoad()
		*!*	THIS.AddShortcutOption_ClassAddtest()
		*!*	THIS.AddShortcutOption_Separator()
		
		*!*	THIS.AddShortcutOption_SelectedRemove()
		*!*	THIS.AddShortcutOption_SelectedReload()
		*!*	THIS.AddShortcutOption_SelectedModify()
		*!*	THIS.AddShortcutOption_Separator()
		
		THIS.AddShortcutOption_FormFont()
		THIS.AddShortcutOption_FormResetfont()
		
		THIS.AddShortcutOption_Separator()
		THIS.AddShortcutOption_FormOptions()
		
		THIS.AddShortcutOption_Separator()
		THIS.AddShortcutOption_FormAcknowledgements()
		THIS.AddShortcutOption_FormLicense()
		
		THIS.ShellShortcutMenuForm()
		
		THIS.AddShortcutOption_Separator()
		THIS.AddShortcutOption_FormClose()
		
		
	ENDPROC

	PROCEDURE shortcutmenugrid
		*
		*  called from THIS.grdTests.RightClick(), this separate method
		*  allows subclassing this method and modifying 
		*  the shortcut menu before THIS.RightClick() issues
		*  the ACTIVATE POPUP
		*
		*  or, you can adjust items by augmenting/overriding
		*  the individual methods where shortcut options
		*  are added
		*
		*  and, you can adjust the menu in THIS.ShellShortcutMenuForm(),
		*  called here before the final option is added to the
		*  shortcut menu
		*  
		
		THIS.inBar = 10
		
		DEFINE POPUP pShortCut IN WINDOW (THIS.Name) SHORTCUT RELATIVE FROM MROW(THIS.Name),MCOL(THIS.Name)
		
		*!*	THIS.AddShortcutOption_RunTestsAll()
		*!*	THIS.AddShortcutOption_RunTestsClass()
		*!*	THIS.AddShortcutOption_RunTestSelected()
		*!*	THIS.AddShortcutOption_Separator()
		
		*!*	THIS.AddShortcutOption_ClassNew()
		*!*	THIS.AddShortcutOption_ClassLoad()
		*!*	THIS.AddShortcutOption_ClassAddtest()
		*!*	THIS.AddShortcutOption_Separator()
		
		*!*	THIS.AddShortcutOption_SelectedRemove()
		*!*	THIS.AddShortcutOption_SelectedReload()
		*!*	THIS.AddShortcutOption_SelectedModify()
		*!*	THIS.AddShortcutOption_Separator()
		
		THIS.AddShortcutOption_FormFont()
		THIS.AddShortcutOption_FormResetfont()
		THIS.AddShortcutOption_Separator()
		
		THIS.AddShortcutOption_GridResetColumnWidths()
		THIS.addShortcutOption_GridSize()
		THIS.AddShortcutOption_Separator()
		
		THIS.AddShortcutOption_GridSortByLocation()
		THIS.AddShortcutOption_GridSortByName()
		
		THIS.ShellShortcutMenuGrid()
		
		
	ENDPROC

	PROCEDURE showprogress		&& Sets the value of the test progress bar as well as the color for pass or fail
		LPARAMETERS tnTestsRun, tlSuccess
		
		IF EMPTY(m.tlSuccess)
			tlFailed = .t.
		ELSE
			IF NOT VARTYPE(m.tlSuccess) = "L" 
				tlSuccess = .t.
			ENDIF
		ENDIF
		
		IF NOT m.tlSuccess
			THIS.pbProgress.shpBar.BackColor = THIS.inColorFail
		ENDIF
		
		THIS.pbProgress.SetValue(m.tnTestsRun)
	ENDPROC

	PROCEDURE togglefilter		&& Turn filter on/off
		ThisForm.cntFilterResults.Visible = This.lFiltered
		ThisForm.grdTests.Top = This.shpButtons.Top + IIF(This.lFiltered,This.cntFilterResults.Height+2,2) + 2
		ThisForm.grdTests.Height = This.sfsplitterv1.Top - This.shpButtons.Top - IIF(This.lFiltered,This.cntFilterResults.Height+2,2) 
		
		IF ThisForm.lFiltered
			This.cntFilterResults.txtClassFilter.SetFocus()
		ELSE
			ThisForm.clearFilter()
		ENDIF
		This.chkFilter.Picture = ;
		IIF(This.lFiltered,'DELETEFILTER_5563_32.BMP','FILTERALPHABETICALLY_5567_32.BMP')
	ENDPROC

	PROCEDURE togglegridsize		&& Switch from large/normal grid size and back
		*
		*  this method is called from the grid-level shortcut menu
		*
		
		IF NOT THIS.ilInitialEntry
			THIS.LOCKSCREEN = .T.
		ENDIF
		
		THIS.ilLargeGrid = ! This.ilLargeGrid
		
		IF THIS.ilLargeGrid
		*
		*  larger
		*
		*	This.grdTests.Anchor = 10
		*	THIS.grdTests.HEIGHT = THIS.pgfDetails.TOP+THIS.pgfDetails.HEIGHT - THIS.grdTests.TOP
			THIS.grdTests.HEIGHT = ThisForm.Height - THIS.grdTests.Top - ThisForm.pbProgress.Height - 30
		
		ELSE
		*
		*  default/normal size
		*
		*	THIS.grdTests.RESETTODEFAULT("Height")
		
			IF VERSION(5)>=900
		*
		*  get the anchor-based proportional size to fire
		*
		*!*			THISFORM.HEIGHT = THISFORM.HEIGHT+1
		*!*			THISFORM.HEIGHT = THISFORM.HEIGHT-1
			ENDIF
		
			ThisForm.grdTests.Height =  This.sfsplitterv1.Top - THIS.grdTests.Top - 1 
		ENDIF
		
		This.pgfDetails.Visible= ! This.ilLargeGrid
		This.sfsplitterv1.Visible = ! This.ilLargeGrid
		
		
		IF NOT THIS.ilInitialEntry
			THIS.LOCKSCREEN = .F.
		ENDIF
		
	ENDPROC

	PROCEDURE underconstruction
		MESSAGEBOX("This feature is under construction", ;
		           48,"Please Note")
		           
	ENDPROC

	PROCEDURE Unload
		*
		*  see THIS.Deactivate()
		*
		RELEASE PAD pFoxUnit OF _MSYSMENU
		
		*
		*  this form is instantiated to this public
		*  variable in FXU.PRG, so RELEASE it now
		*  that this form is about dead
		*
		RELEASE goFoxUnitTestBroker && FXU/JDE 07/01/2004 Added release for goFoxUnitTestBroker
		RELEASE goFoxUnitForm
	ENDPROC

	PROCEDURE updatecurrentgridrowcolor
		LOCAL lnBackColor
		lnBackColor = ;
		     THIS.CalculateRowColor(EVALUATE(THIS.grdTests.RecordSource+".Success"), ;
		                            EVALUATE(THIS.grdTests.RecordSource+".TRun"))
		IF m.lnBackColor = THIS.inColorNotRun
		  THIS.grdTests.HighlightBackColor = THIS.grdTests.SelectedItemBackColor
		 ELSE
		  THIS.grdTests.HighlightBackColor = m.lnBackColor
		ENDIF
		
		
	ENDPROC

	PROCEDURE zreadme
		#IF .f.
		
		Class:  FXU.VCX/frmFoxUnit
		
		If you want to change this FoxUnit interface, your
		best bet is to:
		1- Subclass this form class
		2- Open the \FoxUnit\FXUClassFactory.DBF and update
		the ClassName and ClassLib fields:
		REPLACE ClassName, ClassLib WITH ;
		     "YourSubclassName", "YourSubclassClassLibrary.VCX" ;
		     WHERE UPPER(ALLTRIM(ClassID)) == UPPER("FoxUnitForm")
		...whereupon your subclass of this form is instantiated
		rather than this form when this line of code in FXU.PRG
		executes: 
			goFoxUnitForm = m.loFxuInstance.FxuNewObject("FoxUnitForm")
		
		
		
		********************************************
		*  VDSI notes and action items
		********************************************
		
		Action items for Drew:
		========================================
		THIS.Options()
		FXUOptions.XML 
		Include the UserID, like FXUPersist.XML
		Add the dialog to FXUClassFactory.DBF
			Persist font setting?
			Persist editbox Zoom size?
			ShowTips
			CLOSE DEBUGGER subsequent to running tests
		
		ER submitted by Lauren Clarke on the FoxUnit message board:
		-----------------------------------------------------------
		I like the class/name filters, but would use them even more 
		if they were combo-box based rather than text box with the 
		last 5 filters handy in the drop-down for re-application. 
		You could add a default "no filter" option to each and remove 
		the "Clear filter" button.
		
		ER submitted by Lauren Clarke on the FoxUnit message board:
		-----------------------------------------------------------
		The grid and messages could share reasonable (configurable?) 
		proportions of the vertical realestate. 
		To make more fluid, consider using a browser control for the 
		Failures and Errors/Messages. Then a horizontal divider could 
		be used to control the relative sizes of the grid and message 
		display area. Also, with a browser agent in place, we open 
		the door to customized scripts (xslt or other) to determine 
		the layout of the errors and messages. 
		
		ER submitted by Lauren Clarke on the FoxUnit message board:
		-----------------------------------------------------------
		Allow option to halt on first failure in UI
		
		ER submitted by Sietse Wijnker on the FoxUnit Message board (09/10/2004)
		-----------------------------------------------------------
		Make captions of Errors/Failures and Messages pageframes
		bold when selecting a test that has non-empty memo fields
		Suggest adding the following lines to the 
		frmFxuFoxunit::Afterruntests() method
		*	This.pgfDetails.pgFailuresAndErrors.FontBold = ;
		*		NOT EMPTY(THIS.pgfDetails.pgFailuresAndErrors.edtFailuresAndErrors.text) 
		*	This.pgfDetails.pgMessages.FontBold = ;
		*		NOT EMPTY(THIS.pgfDetails.pgMessages.edtMessages.text) 
		beneath the refresh() calls of the edit-boxes 
		
		ER submitted by Andrew Ross McNeil on the FoxUnit Message board (08/21/2004):
		-----------------------------------------------------------
		Allow creation of test classes from existing classes:
		CREATE a form that allows a user to select an existing class.
		This will populate a grid with all of public methods
		from the class with checkboxes. Each method checked would
		be used to create a stub test class for the class
		selected.
		
		#ENDIF
		
	ENDPROC

	PROCEDURE chkFilter.Click
		ThisForm.toggleFilter()
		
	ENDPROC

	PROCEDURE cmdAddNewTest.Click
		THISFORM.ioResultData.AddNewTest( ;
		     ALLTRIM(EVALUATE(THISFORM.icGridRS+".TClass")), ;
		     THISFORM, ;
		     ALLTRIM(EVALUATE(THISFORM.icGridRS+".TPath")) ;
		     ) && Added Path parameter to call. HAS
		
		*
		*  no THISFORM.Refresh() here, because AddNewTest()
		*  calls the EDITSOURCE() function, which doesn't
		*  pause program execution the way MODIFY COMMAND
		*  does
		*
		*  rather, FXUResultData::AddNewTest() sets a custom
		*  THISFORM.ilReloadCurrentClassOnActivate flag property
		*  that is checked in THISFORM.Activate
		*
		
		
		
		
	ENDPROC

	PROCEDURE cmdCloseAll.Click
		
		IF MESSAGEBOX("Close all test classes?", 4+48+256, "Close All") = 7
		*  get focus off this button
			KEYBOARD "{TAB}" PLAIN CLEAR
			RETURN
		ENDIF
		
		THISFORM.ioREsultData.RemoveAllTestCaseClasses()
		
		THISFORM.AfterRunTests()
		
	ENDPROC

	PROCEDURE cmdCloseAll.Init
		THIS.ToolTipText = ;
		     "Close all Test Classes" + ;
		     CHR(13) + CHR(13) + ;
		     "Note that the Test Classes (.PRG) are NOT deleted " + ;
		     "from disk; rather just its entries in the FoxUnit " + ;
		     "results table in the list below are deleted."
		     
	ENDPROC

	PROCEDURE cmdCreateNewTestClass.Click
		LOCAL lcNewClassPRG
		lcNewClassPRG = SPACE(0)
		
		*
		*  MODIFY COMMAND FXUResultData
		*    XXDTES("FXURESULTDATA.PRG","FUNCTION CreateNewTestCaseClass(tcTestsPath,tcTestClassPRG)    ")
		*
		
		THISFORM.ioResultData.CreateNewTestCaseClass( ;
		    ADDBS(JUSTPATH(FULLPATH(DBF(THISFORM.icGridRS)))), ;
		    @m.lcNewClassPRG ;
		    )
		
		THISFORM.AfterRunTests()
		
		THISFORM.Refresh()
		
		
	ENDPROC

	PROCEDURE cmdLoadNewTestClass.Click
		
		THISFORM.ioResultData.LoadTestCaseClass()
		
		THISFORM.AfterRunTests()
		
		THISFORM.Refresh()
		
	ENDPROC

	PROCEDURE cmdModifySelected.Click
		THISFORM.ioResultData.ModifyExistingTest( ;
		     ALLTRIM(EVALUATE(THISFORM.icGridRS+".TClass")), ;
		     ALLTRIM(EVALUATE(THISFORM.icGridRS+".TName")), ;
		     THISFORM, ;
		     ALLTRIM(EVALUATE(THISFORM.icGridRS+".TPath")) ;
		     ) && Added Path parameter to call. HAS
		
		*
		*  no THISFORM.Refresh() here, because ModifyTest()
		*  calls the EDITSOURCE() function, which doesn't
		*  pause program execution the way MODIFY COMMAND
		*  does
		*
		*  rather, FXUResultData::ModifyTest() sets a custom
		*  THISFORM.ilReloadCurrentClassOnActivate flag property
		*  that is checked in THISFORM.Activate
		*
		
		
		
		
	ENDPROC

	PROCEDURE cmdOptions.Click
		_Screen.ActiveForm.Options()
	ENDPROC

	PROCEDURE cmdReloadSelectedTestClass.Click
		ThisForm.ReloadSelectedTestClass()
	ENDPROC

	PROCEDURE cmdRemoveTestClass.Click
		
		IF MESSAGEBOX("Remove the entire .PRG/Class containing the currently-selected " + ;
				ALLTRIM(EVALUATE(THISFORM.icGridRS+".TName")) + " test?", ;
				4+48+256,"Remove this .PRG?") = 7
		*  get focus off this button
			KEYBOARD "{TAB}" PLAIN CLEAR
			RETURN
		ENDIF
		
		THISFORM.ioResultData.RemoveTestCaseClass(EVALUATE(THISFORM.icGridRS+".TClass"))
		
		THISFORM.AfterRunTests()
		
	ENDPROC

	PROCEDURE cmdRemoveTestClass.Init
		THIS.ToolTipText = ;
		     "Close the Test Class (.PRG) containing " + ;
		     "the currently-selected Test" + ;
		     CHR(13) + CHR(13) + ;
		     "Note that the Test Class (.PRG) is NOT deleted " + ;
		     "from disk; rather just its entries in the FoxUnit " + ;
		     "results table in the list below are deleted."
		     
	ENDPROC

	PROCEDURE cmdRunTestsAll.Click
		THISFORM.RunAllTests()
	ENDPROC

	PROCEDURE cmdRunTestsOne.Click
		THISFORM.RunOneTest( ;
		                    ALLTRIM(EVALUATE(THISFORM.icGridRS+".TClass")), ;
		                    ALLTRIM(EVALUATE(THISFORM.icGridRS+".TName")), ;
		                    ALLTRIM(EVALUATE(THISFORM.icGridRS+".TPath")) ;
		                    ) && Added path to call. HAS
		                    
	ENDPROC

	PROCEDURE cmdRunTestsOneClass.Click
		THISFORM.RunClassTests(EVALUATE(THISFORM.icGridRS+".TClass"))
	ENDPROC

	PROCEDURE cntFilterResults.chkFailedOnly.Click
		THISFORM.ApplyFilter()
	ENDPROC

	PROCEDURE cntFilterResults.cmdReset.Click
		ThisForm.clearFilter()
		
	ENDPROC

	PROCEDURE cntFilterResults.lblClassFilter.Init
		THIS.ToolTipText = THISFORM.GetFilterToolTipText()
	ENDPROC

	PROCEDURE cntFilterResults.lblClassFilter.RightClick
		THISFORM.RightClick()
	ENDPROC

	PROCEDURE cntFilterResults.lblNameFilter.Init
		IF VERSION(5) >= 900
			THIS.Anchor = 160	&& FDBOZZO
		ENDIF
		THIS.ToolTipText = THISFORM.GetFilterToolTipText()
	ENDPROC

	PROCEDURE cntFilterResults.lblNameFilter.RightClick
		THISFORM.RightClick()
	ENDPROC

	PROCEDURE cntFilterResults.shpFilter.Init
		IF NOT DODEFAULT()
		  RETURN .F.
		ENDIF
		
		*!*	THIS.Top = 1
		*!*	THIS.Left = 1
		*!*	THIS.Width = THISFORM.Width-1
		*!*	THIS.Height = 44
		
	ENDPROC

	PROCEDURE cntFilterResults.txtClassFilter.GotFocus
		THIS.AddProperty("icValueOnGotFocus",THIS.Value)
		
	ENDPROC

	PROCEDURE cntFilterResults.txtClassFilter.Init
		IF VERSION(5) >= 900
			THIS.Anchor = 130	&& FDBOZZO
		ENDIF
		THIS.InputMask = REPLICATE("X",60)
		THIS.ToolTipText = THISFORM.GetFilterToolTipText()
	ENDPROC

	PROCEDURE cntFilterResults.txtClassFilter.LostFocus
		IF UPPER(ALLTRIM(THIS.icValueOnGotFocus)) == UPPER(ALLTRIM(THIS.Value))
		  *
		  *  no change/update
		  *
		 ELSE 
		  THISFORM.ApplyFilter()
		ENDIF
		  
	ENDPROC

	PROCEDURE cntFilterResults.txtClassFilter.RightClick
		THISFORM.RightClick()
	ENDPROC

	PROCEDURE cntFilterResults.txtNameFilter.GotFocus
		THIS.AddProperty("icValueOnGotFocus",THIS.Value)
		
	ENDPROC

	PROCEDURE cntFilterResults.txtNameFilter.Init
		IF VERSION(5) >= 900
			THIS.Anchor = 40	&& FDBOZZO
		ENDIF
		THIS.InputMask = REPLICATE("X",60)
		THIS.ToolTipText = THISFORM.GetFilterToolTipText()
	ENDPROC

	PROCEDURE cntFilterResults.txtNameFilter.LostFocus
		IF UPPER(ALLTRIM(THIS.icValueOnGotFocus)) == UPPER(ALLTRIM(THIS.Value))
		  *
		  *  no change/update
		  *
		 ELSE 
		  THISFORM.ApplyFilter()
		ENDIF
		
	ENDPROC

	PROCEDURE cntFilterResults.txtNameFilter.RightClick
		THISFORM.RightClick()
	ENDPROC

	PROCEDURE grdTests.AfterRowColChange
		LPARAMETERS nColIndex
		
		THIS.Column2.Header1.Caption = ;
		     "Test name (" + ALLTRIM(EVALUATE(THIS.RecordSource+".TClass")) + "::" + ALLTRIM(EVALUATE(this.RecordSource+".TName")) +")"
		
		THISFORM.AfterRunTests(.t.)
		
		
		
	ENDPROC

	PROCEDURE grdTests.BeforeRowColChange
		LPARAMETERS nColIndex
		
		THISFORM.inMostRecentSelectedRow = THIS.ActiveRow
		
	ENDPROC

	PROCEDURE grdTests.DblClick
		THISFORM.cmdModifySelected.Click()
	ENDPROC

	PROCEDURE grdTests.Init
		IF !USED(thisform.icgridrs)
			RETURN
		ENDIF
		
		*
		*  set THIS.HighlightBackColor to the SelectedItems
		*  color set in Windows on this machine
		
		*
		THIS.HighlightBackColor = THIS.SelectedItemBackColor
		
		*
		*  gray BackColor
		*
		THIS.BackColor = THISFORM.inColorNotRun
		
		*
		*  basic setup
		*
		
		THIS.RecordSource = THISFORM.icGridRS
		
		*!*	THIS.Column1.ControlSource = THIS.RecordSource + ".TClass"
		*!*	THIS.Column1.ControlSource = ;
		*!*	     [IIF(FXUResults.Location=1,FXUResults.TClass,SPACE(4)+FXUResults.TClass)]
		*!*	THIS.Column1.ControlSource = ;
		*!*	     [IIF(] + THIS.RecordSource + [.Location=1,] + THIS.RecordSource + [.TClass,SPACE(5)+] + THIS.RecordSource + [.TClass)]
		*!*	THIS.Column1.ControlSource = ;
		*!*	     [IIF(ORDER("FXUResults")="TCLOC" AND NOT FXUResults.Location=1,SPACE(4)+FXUResults.TClass,FXUResults.TClass)]
		*
		*  indent each test after the first one, within each
		*  test class .PRG
		*
		THIS.Column1.ControlSource = ;
		     [IIF(ORDER("] + THIS.RecordSource + [")="TCLOC" AND NOT ] + THIS.RecordSource + [.Location=1,SPACE(4)+] + THIS.RecordSource + [.TClass,] + THIS.RecordSource + [.TClass)]
		
		THIS.Column2.ControlSource = THIS.RecordSource + ".TName"
		
		*
		*  format THIS.Column3 to H:MM:SS.nnn
		*
		*	LOCAL lcString
		*	lcString = ;
		*	     "TRANSFORM(INT("+THIS.RecordSource+".TElapsed/(60*60))) + ':' + " + ;
		*	     "PADL(INT("+THIS.RecordSource+".TElapsed/60),2,'0') + ':' + " + ;
		*	     "PADL(MOD(INT("+THIS.RecordSource+".TElapsed),60),2,'0') + '.' + " + ;
		*	     "RIGHTC(STR("+THIS.RecordSource+".TElapsed,10,3),3)" 
		*	THIS.Column3.ControlSource = "(" + m.lcString + ")"
		
		*
		*  other setup
		*
		
		THIS.AllowCellSelection = .f.
		THIS.GridLines = 0
		
		THIS.SetAll("DynamicBackColor","THISFORM.CalculateRowColor(Success,TRun)","Column")
		
		THIS.SetAll("DynamicFontItalic",[NOT FILE(FORCEEXT(ALLTRIM(FXUResults.TClass),"PRG"))],"Column")
		
		THIS.SetAll("Movable",.f.,"Column")
		
		THIS.ToolTipText = ;
		"Shortcut menu available" + ;
		     CHR(13) + CHR(13) + ;
		"{CTRL+PgUp} to navigate down to the next Test Class" + ;
		     CHR(13) + ;
		"{CTRL+PgDn} to navigate up to the previous Test Class" + ;
		     CHR(13) + ;
		"{CTRL+S} to toggle the grid size"
		
		IF VERSION(5)>=900
		  *
		  *    1 = Top Absolute
		  *    2 = Left Absolute
		  *  128 = Right Relative
		  *   64 = Bottom Relative
		  *
		 * THIS.Anchor = 1 + 2 + 128 + 64
		  THIS.Anchor = 10 && Matt Slay 2013-12-16
		ENDIF
		
		
		
	ENDPROC

	PROCEDURE grdTests.Resize
		IF VERSION(5) >= 900
			THIS.Column2.Width = ;
		    	THIS.Width - THIS.Column1.Width - SYSMETRIC(5) - 14
		
		ENDIF
		
	ENDPROC

	PROCEDURE grdTests.RightClick
		IF THISFORM.ShortcutMenuGrid()
		  ACTIVATE POPUP pShortCut
		ENDIF
		
	ENDPROC

	PROCEDURE grdTests.Valid
		*
		*  see THIS.When and THISFORM.KeyPress
		*
		THISFORM.KeyPreview = .f.
	ENDPROC

	PROCEDURE grdTests.When
		*
		*  When THISFORM.KeyPreview is set to .F., the preferred
		*  default behavior for performance reasons, 
		*  set THISFORM.KeyPreview to .T. ONLY when this grid
		*  is the active control (see also THIS.Valid).
		*
		*  This code is here to support a workaround for
		*  an ugly intrinsic behavior when:
		*    1- THIS.AllowCellSelection = .F.
		*    2- The total widths of all the columns exactly
		*       fill the available horizontal space inside
		*       the grid, no pixels between the last/rightmost
		*       column and the vertical scrollbar
		*    3- THIS grid has focus
		*    4- The user presses the {RightArrow} key
		*  whereupon the grid contents scrolls to the left,
		*  leaving an empty space on the right.
		*  This behavior is similar to the workarounds in 
		*  this class for an implicit and ugly leftward
		*  scrolling in other situations, fixed by the
		*  DoScroll(6) calls in this class.
		*  
		THISFORM.KeyPreview = .t.
		
		*
		*  ...and to support the {CTRL+PgUp} and {CTRL+PgDn}
		*  hotkeys...
		*
		
		
	ENDPROC

	PROCEDURE lblAllResults.Init
		IF DODEFAULT()
			IF VERSION(5)>=900
				THIS.ANCHOR = 4+8
			ENDIF
		ENDIF
		
		THIS.CAPTION = SPACE(0)
		
	ENDPROC

	PROCEDURE lblElapsedTime.Init
		IF DODEFAULT()
			IF VERSION(5)>=900
				THIS.ANCHOR = 4+2
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE lblTestsRunTestsFailed.Init
		IF DODEFAULT()
			IF VERSION(5)>=900
				THIS.ANCHOR = 4+2
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE lblTimeElapsed.Init
		IF NOT DODEFAULT()
		  RETURN .F.
		ENDIF
		
		IF VERSION(5)>=900
		  *
		  *    4 = Bottom Absolute
		  *    2 = Left Absolute
		  *
		  THIS.Anchor = 4 + 2  
		ENDIF
		
		THIS.Caption = SPACE(0)
	ENDPROC

	PROCEDURE pbProgress.Init
		LPARAMETERS tnMin, tnMax, tlCenter
		
		IF DODEFAULT(tnMin, tnMax, tlCenter)
			IF VERSION(5)>=900
			  *
			  *    64 = Bottom Relative
			  *    2 = Left Absolute
			  *    128 = Right Absolute
			  *
			  THIS.Anchor = 64 + 2 + 128
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE pbProgress.lblPercent.Init
		IF DODEFAULT()
			IF VERSION(5)>=900
			  THIS.Anchor = THIS.Parent.Anchor
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE pbProgress.shpBar.Init
		IF NOT DODEFAULT()
		  RETURN .F.
		ENDIF
		
		IF VERSION(5)>=900
		  THIS.Anchor = THIS.Parent.Anchor
		ENDIF
	ENDPROC

	PROCEDURE pgfDetails.Init
		IF NOT DODEFAULT()
		  RETURN .F.
		ENDIF
		
		IF VERSION(5)>=900
		  *
		  *   16 = Top Relative
		  *    2 = Left Absolute
		  *  128 = Right Relative
		  *   64 = Bottom Relative
		  *
		  *THIS.Anchor = 16 + 2 + 128 + 64
		  THIS.Anchor = 15 && Matt Slay 2013-12-16
		
		ENDIF
	ENDPROC

	PROCEDURE pgfDetails.pgFailuresAndErrors.cmdCompare.Click
		*========================================================================================
		* Compare the two values by executing an external tool
		*========================================================================================
		
			*--------------------------------------------------------------------------------------
			* Generate temporary files for actual and expected content
			*--------------------------------------------------------------------------------------
			Local lcFileBase, lcActual, lcExpected
			lcFileBase = AddBS(GetEnv("TEMP")) + ;
				"FoxUnit_" + Transform(_Vfp.ProcessId) + Sys(2015) + "_"
			lcActual = Evaluate(THISFORM.icGridRS + ".Actual")
			StrToFile(m.lcActual, m.lcFileBase+"Actual")
			lcExpected = Evaluate(THISFORM.icGridRS + ".Expected")
			StrToFile(m.lcExpected, m.lcFileBase+"Expected")
		
			*--------------------------------------------------------------------------------------
			* Determine parameters
			*--------------------------------------------------------------------------------------
			Local lcParams
			lcParams = Evl(Thisform.icCompareParameters, "%1 %2")
			lcParams = Strtran(m.lcParams, "%1", '"'+m.lcFileBase+'Expected"')
			lcParams = Strtran(m.lcParams, "%2", '"'+m.lcFileBase+'Actual"')
			
			*--------------------------------------------------------------------------------------
			* Launch comparision utility
			*--------------------------------------------------------------------------------------
			Local lcTool
			lcTool = '"' + Thisform.icCompareTool + '"'
			Thisform.ExecApplication (m.lcTool + " " + m.lcParams)
		
		
	ENDPROC

	PROCEDURE pgfDetails.pgFailuresAndErrors.cmdCompare.Init
		IF NOT DODEFAULT()
		  RETURN .F.
		ENDIF
		
		IF VERSION(5)>=900
		  THIS.Anchor = 8
		ENDIF
		
	ENDPROC

	PROCEDURE pgfDetails.pgFailuresAndErrors.cmdCompare.Refresh
		*========================================================================================
		* Compare is only available, if there is a tool and data to compare.
		*========================================================================================
		
			Local lcActual, lcExpected
			Do case
			Case not Used(THISFORM.icGridRS)
				This.Enabled = .F.
			Case Empty(Thisform.icCompareTool)
				This.Enabled = .F.
			Otherwise
				lcActual = Evaluate(THISFORM.icGridRS + ".Actual")
				lcExpected = Evaluate(THISFORM.icGridRS + ".Expected")
				If Empty(m.lcActual) and Empty(m.lcExpected)
					This.Enabled = .F.
				Else
					This.Enabled = .T.
				EndIf
			EndCase
		
	ENDPROC

	PROCEDURE pgfDetails.pgFailuresAndErrors.cmdCompare.UIEnable
		LPARAMETERS lEnable
		
		IF m.lEnable
		  THIS.Refresh()
		ENDIF
		
	ENDPROC

	PROCEDURE pgfDetails.pgFailuresAndErrors.edtFailuresAndErrors.Init
		IF NOT DODEFAULT()
		  RETURN .F.
		ENDIF
		
		&&	THIS.ControlSource = THISFORM.icGridRS + ".Fail_Error"
		
		IF VERSION(5)>=900
		  *
		  *   16 = Top Relative
		  *    2 = Left Absolute
		  *  128 = Right Relative
		  *   64 = Bottom Relative
		  *
		  *THIS.Anchor = 16 + 2 + 128 + 64
		  THIS.Anchor = 15 && Matt Slay 2013-12-16
		ENDIF
		
	ENDPROC

	PROCEDURE pgfDetails.pgFailuresAndErrors.edtFailuresAndErrors.RightClick
		IF THISFORM.ShortcutMenuEditBox(THIS)
		  ACTIVATE POPUP pShortCut
		ENDIF
		
	ENDPROC

	PROCEDURE pgfDetails.pgFailuresAndErrors.edtFailuresAndErrors.UIEnable
		LPARAMETERS lEnable
		
		IF m.lEnable
		  THIS.Refresh()
		ENDIF
		
	ENDPROC

	PROCEDURE pgfDetails.pgMessages.edtMessages.Init
		IF NOT DODEFAULT()
		  RETURN .f.
		ENDIF
		
		&&	THIS.ControlSource = THISFORM.icGridRS + ".Messages"
		
		IF VERSION(5)>=900
		  *
		  *   16 = Top Relative
		  *    2 = Left Absolute
		  *  128 = Right Relative
		  *   64 = Bottom Relative
		  *
		  *THIS.Anchor = 16 + 2 + 128 + 64
		  THIS.Anchor = 15 && Matt Slay 2013-12-16
		
		ENDIF
	ENDPROC

	PROCEDURE pgfDetails.pgMessages.edtMessages.RightClick
		IF THISFORM.ShortcutMenuEditbox(THIS)
		  ACTIVATE POPUP pShortCut
		ENDIF
		
	ENDPROC

	PROCEDURE pgfDetails.pgMessages.edtMessages.UIEnable
		LPARAMETERS lEnable
		
		IF m.lEnable
		  THIS.Refresh()
		ENDIF
		
	ENDPROC

	PROCEDURE Sfsplitterv1.Init
		DoDefault()
		
		
		** Matt Slay 2013-12-16
		IF VERSION(5) >= 900
		  THIS.Anchor = 10 
		ENDIF
	ENDPROC

	PROCEDURE shpButtons.Init
		IF NOT DODEFAULT()
		  RETURN .F.
		ENDIF
		
		*!*	THIS.Top = 1
		*!*	THIS.Left = 1
		*!*	THIS.Width = THISFORM.Width-1
		*!*	THIS.Height = 44
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmgettestclasstemplate AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdSelectTemplate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lstTemplates" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkProcedure" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkTab" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSelectCustomTemplate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCopyExistingPRG" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblOR1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblOR2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCancel" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addcustomtemplates
		*m: addtemplate
		*m: addvmptemplates
		*m: getyourfxutemplate
		*m: getyourfxutesttocopy
		*m: modifytemplate
		*m: removemissingtemplates
		*m: removetemplate
		*m: restoresettings
		*m: savesettings
		*m: sortoptionaltemplates
		*m: templateclassinheritsfromfxutestcase
		*m: validatederivedtestcasetemplate
		*m: validtemplatefile
		*m: zreadme
		*p: icnewtestclass
		*p: icresultvariable
		*p: inpermanenttemplates
		*p: iuretval
		*a: iatemplates[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	AllowOutput = .F.
	AutoCenter = .T.
	Caption = "Specify the FoxUnit test class template "
	ControlBox = .F.
	DoCreate = .T.
	Height = 440
	inpermanenttemplates = 0
	iuretval = .NULL.
	MaxButton = .F.
	MinButton = .F.
	Name = "frmgettestclasstemplate"
	ShowInTaskBar = .F.
	ShowTips = .T.
	ShowWindow = 1
	Width = 640
	WindowType = 1
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'chkProcedure' AS checkbox WITH ;
		Alignment = 0, ;
		BackStyle = 0, ;
		Caption = 'Use "PROCEDURE MethodName" rather than "FUNCTION MethodName" for method names?', ;
		Enabled = .F., ;
		Height = 17, ;
		Left = 32, ;
		Name = "chkProcedure", ;
		TabIndex = 2, ;
		Top = 164, ;
		Value = .F., ;
		Width = 540
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkTab' AS checkbox WITH ;
		Alignment = 0, ;
		BackStyle = 0, ;
		Caption = "Indent methods by one TAB?", ;
		Enabled = .F., ;
		Height = 17, ;
		Left = 32, ;
		Name = "chkTab", ;
		TabIndex = 3, ;
		Top = 180, ;
		Value = .T., ;
		Width = 180
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		Cancel = .T., ;
		Caption = "\<Cancel", ;
		FontName = "Tahoma", ;
		Height = 39, ;
		Left = 544, ;
		Name = "cmdCancel", ;
		Picture = ("FXUCancel.BMP"), ;
		TabIndex = 7, ;
		Top = 384, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdCopyExistingPRG' AS commandbutton WITH ;
		Caption = "Copy an existing FoxUnit test case class (.PRG) to the new test case class", ;
		Default = .T., ;
		FontName = "Tahoma", ;
		Height = 40, ;
		Left = 52, ;
		Name = "cmdCopyExistingPRG", ;
		TabIndex = 6, ;
		Top = 328, ;
		Width = 576, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSelectCustomTemplate' AS commandbutton WITH ;
		Caption = "Select a custom FoxUnit template of your own.  If you select one that is not in the list above, it will be automatically added to the list the next time you invoke this dialog.", ;
		Default = .F., ;
		FontName = "Tahoma", ;
		Height = 40, ;
		Left = 52, ;
		Name = "cmdSelectCustomTemplate", ;
		TabIndex = 5, ;
		Top = 264, ;
		Width = 576, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSelectTemplate' AS commandbutton WITH ;
		Caption = "Select the FoxUnit test case template that is currently selected in the above list.  Maintain the list via the shortcut menu options for the list.", ;
		Default = .F., ;
		FontName = "Tahoma", ;
		Height = 40, ;
		Left = 12, ;
		Name = "cmdSelectTemplate", ;
		TabIndex = 4, ;
		Top = 200, ;
		Width = 616, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'lblCancel' AS label WITH ;
		BackStyle = 0, ;
		Caption = "(or Cancel/close this form if you have changed your mind and don't want to create a new FoxUnit test case class)", ;
		FontName = "Tahoma", ;
		Height = 32, ;
		Left = 220, ;
		Name = "lblCancel", ;
		Top = 388, ;
		Width = 316, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblOR1' AS label WITH ;
		BackStyle = 0, ;
		Caption = "-OR-", ;
		FontBold = .T., ;
		FontName = "Tahoma", ;
		FontSize = 12, ;
		Height = 17, ;
		Left = 12, ;
		Name = "lblOR1", ;
		Top = 272, ;
		Width = 40
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblOR2' AS label WITH ;
		BackStyle = 0, ;
		Caption = "-OR-", ;
		FontBold = .T., ;
		FontName = "Tahoma", ;
		FontSize = 12, ;
		Height = 17, ;
		Left = 12, ;
		Name = "lblOR2", ;
		Top = 340, ;
		Width = 40
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lstTemplates' AS listbox WITH ;
		ColumnCount = 2, ;
		ColumnLines = .F., ;
		ColumnWidths = "304,336", ;
		FontName = "Tahoma", ;
		Height = 148, ;
		IntegralHeight = .T., ;
		ItemTips = .T., ;
		Left = 12, ;
		Name = "lstTemplates", ;
		TabIndex = 1, ;
		Top = 12, ;
		Width = 616
		*< END OBJECT: BaseClass="listbox" />
	
	PROCEDURE addcustomtemplates
	ENDPROC

	PROCEDURE addtemplate
		*
		*  called from THIS.lstTemplates.RightClick() 
		*  and from THIS.GetYourFXUTemplate()
		*
		LPARAMETERS tcFileName
		
		LOCAL lcFileName, xx, lcDescription, lnRow, yy, llAlready
		
		IF PCOUNT() = 0
		  lcFileName = GETFILE("TXT","FoxUnit template","Select",0,"Select a FoxUnit test class .TXT template")
		 ELSE
		  lcFileName = m.tcFileName
		ENDIF
		IF EMPTY(m.lcFileName)
		  RETURN
		ENDIF
		
		lcFileName = UPPER(ALLTRIM(m.lcFileName))
		
		FOR xx = 1 TO ALEN(THIS.iaTemplates,1)
		  IF UPPER(ALLTRIM(THIS.iaTemplates[m.xx,3])) == m.lcFileName
		    llAlready = .t.
		    EXIT
		  ENDIF
		ENDFOR
		IF m.llAlready
		  MESSAGEBOX(m.lcFileName + " is already in the list!", ;
		             16, ;
		             "Please Note")
		  RETURN
		ENDIF
		
		IF NOT THIS.ValidTemplateFile(m.lcFileName)
		  MESSAGEBOX(JUSTFNAME(m.lcFileName) + ;
		             " is not a FoxUnit test case class inheriting from FXUTestCase.PRG", ;
		             48, ;
		             "Please Note")
		  RETURN
		ENDIF
		
		IF PCOUNT() = 0
		  lcDescription = INPUTBOX("Description", ;
		                           "Enter a short description")
		ENDIF
		IF EMPTY(m.lcDescription)
		  lcDescription = "Custom FoxUnit template"
		ENDIF
		
		*
		*  add it
		*
		lnRow = ALEN(THIS.iaTemplates,1)+1
		DIMENSION THIS.iaTemplates[m.lnRow,ALEN(THIS.iaTemplates,2)]
		THIS.iaTemplates[m.lnRow,1] = m.lcDescription
		THIS.iaTemplates[m.lnRow,2] = JUSTFNAME(m.lcFileName)
		THIS.iaTemplates[m.lnRow,3] = m.lcFileName
		
		THIS.SortOptionalTemplates()
		
		THIS.lstTemplates.Value = m.lnRow
		THIS.lstTemplates.RowSource = THIS.lstTemplates.RowSource
		
		                         
		                         
		
		
	ENDPROC

	PROCEDURE addvmptemplates
		*
		*  FXU.VCX/frmGetTestClassTemplate::AddVMPTemplates()  
		*
		*
		*  add VMP-specific (Visual MaxFrame Professional) templates
		*
		IF NOT FILE("XXFW.VCX")
		  RETURN
		ENDIF
		
		LOCAL lnRow, lnCols, lcCurDir, lcXLIB, laFiles[1], lnFiles, xx, ;
		      lcFileName, lcDesc, lcDescText, laLines[1] 
		lnRow = ALEN(THIS.iaTemplates,1)
		lnCols = ALEN(THIS.iaTemplates,2)
		lcCurDir = FULLPATH(CURDIR())
		lcXLIB = JUSTPATH(FULLPATH("XXFW.VCX"))
		
		CD (m.lcXLIB)
		
		lnFiles = ADIR(laFiles,"VMPFXU*.TXT")
		
		CD (m.lcCurDir)
		
		IF m.lnFiles = 0
		  RETURN
		ENDIF
		
		FOR xx = 1 TO m.lnFiles
		  lcFileName = UPPER(laFiles[m.xx,1])
		  IF NOT "TEMPLATE" $ m.lcFileName
		    LOOP 
		  ENDIF
		  IF ASCAN(THIS.iaTemplates,m.lcFileName,-1,-1,2,15)>0
		    *  already in the list
		    LOOP 
		  ENDIF
		  lnRow = m.lnRow + 1
		  DIMENSION THIS.iaTemplates[m.lnRow,m.lnCols]
		  ALINES(laLines,FILETOSTR(m.lcFileName))  
		  lcDescText = laLines[2]   &&& description is on the 2nd line of the .TXT template file 
		  lcDescText = ALLTRIM(SUBSTRC(m.lcDescText,2))   &&& remove leading asterisk
		  
		*!*	  DO CASE
		*!*	    CASE RIGHTC(m.lcFileName,7) = "_DS.TXT"
		*!*	      lcDescText = "VMP DataSource test case template"
		*!*	    CASE RIGHTC(m.lcFileName,7) = "_BO.TXT"
		*!*	      lcDescText = "VMP Business Object test case template"
		*!*	    CASE RIGHTC(m.lcFileName,16) = "_BO_ONE2MANY.TXT"
		*!*	      lcDescText = "VMP One2Many Business Object test case template"
		*!*	    CASE RIGHTC(m.lcFileName,21) = "_BO_ONE2MANY2MANY.TXT"
		*!*	      lcDescText = "VMP One2Many2Many Business Object test case template"
		*!*	    OTHERWISE
		*!*	      lcDescText = "VMP test case template"
		*!*	  ENDCASE
		
		  THIS.iaTemplates[m.lnRow,1] = m.lcDescText
		  THIS.iaTemplates[m.lnRow,2] = laFiles[m.xx,1]
		  THIS.iaTemplates[m.lnRow,3] = FULLPATH(m.lcFileName)
		  THIS.iaTemplates[m.lnRow,4] = .t.   &&& permanent
		ENDFOR
		
		
		
		*!*	IF FILE("VMPFXUTestCaseTemplate_DS.TXT") ;
		*!*	     AND NOT ASCAN(THIS.iaTemplates,"VMPFXUTestCaseTemplate_DS.TXT",-1,-1,2,15)>0
		*!*	  lnRow = m.lnRow + 1
		*!*	  DIMENSION THIS.iaTemplates[m.lnRow,m.lnCols]
		*!*	  THIS.iaTemplates[m.lnRow,1] = "VMP DataSource test case template"
		*!*	  THIS.iaTemplates[m.lnRow,2] = "VMPFXUTestCaseTemplate_DS.TXT"
		*!*	  THIS.iaTemplates[m.lnRow,3] = FULLPATH(THIS.iaTemplates[m.lnRow,2])
		*!*	  THIS.iaTemplates[m.lnRow,4] = .t.   &&& permanent
		*!*	ENDIF
		
		*!*	IF FILE("VMPFXUTestCaseTemplate_BO.TXT") ;
		*!*	     AND NOT ASCAN(THIS.iaTemplates,"VMPFXUTestCaseTemplate_BO.TXT",-1,-1,2,15)>0
		*!*	  lnRow = m.lnRow + 1
		*!*	  DIMENSION THIS.iaTemplates[m.lnRow,m.lnCols]
		*!*	  THIS.iaTemplates[m.lnRow,1] = "VMP Business Object test case template"
		*!*	  THIS.iaTemplates[m.lnRow,2] = "VMPFXUTestCaseTemplate_BO.TXT"
		*!*	  THIS.iaTemplates[m.lnRow,3] = FULLPATH(THIS.iaTemplates[m.lnRow,2])
		*!*	  THIS.iaTemplates[m.lnRow,4] = .t.   &&& permanent
		*!*	ENDIF
		
		*!*	IF FILE("VMPFXUTestCaseTemplate_BO_One2Many.TXT") ;
		*!*	     AND NOT ASCAN(THIS.iaTemplates,"VMPFXUTestCaseTemplate_BO_One2Many.TXT",-1,-1,2,15)>0
		*!*	  lnRow = m.lnRow + 1
		*!*	  DIMENSION THIS.iaTemplates[m.lnRow,m.lnCols]
		*!*	  THIS.iaTemplates[m.lnRow,1] = "VMP One2Many Business Object test case template"
		*!*	  THIS.iaTemplates[m.lnRow,2] = "VMPFXUTestCaseTemplate_BO_One2Many.TXT"
		*!*	  THIS.iaTemplates[m.lnRow,3] = FULLPATH(THIS.iaTemplates[m.lnRow,2])
		*!*	  THIS.iaTemplates[m.lnRow,4] = .t.   &&& permanent
		*!*	ENDIF
		
		THIS.lstTemplates.RowSource = THIS.lstTemplates.RowSource
		
	ENDPROC

	PROCEDURE Destroy
		THIS.SaveSettings()
		
	ENDPROC

	PROCEDURE getyourfxutemplate
		*  
		*  called from THIS.cmdSelectCustomTemplate.Click()
		*
		
		
		LOCAL lcFileName, xx, llAlready
		
		lcFileName = GETFILE("TXT","FoxUnit template","Select",0,"Select a FoxUnit test class .TXT template")
		
		IF EMPTY(m.lcFileName)
		  RETURN
		ENDIF
		
		IF NOT THIS.ValidTemplateFile(m.lcFileName)
		  IF MESSAGEBOX(JUSTFNAME(m.lcFileName) + ;
		             " is not a FoxUnit test case class inheriting from FXUTestCase.PRG." + ;
		             CHR(10) + "Do you wish to load this test case template anyway?", ;
		             4+48,  ;
		             "Please Note") = 7
		  	RETURN
		  ENDIF
		ENDIF
		
		*
		*  if the selected template isn't already in the list,
		*  put it in the list so it's there from now on
		*
		FOR xx = 1 TO ALEN(THIS.iaTemplates,1)
		  IF UPPER(ALLTRIM(THIS.iaTemplates[m.xx,3])) == m.lcFileName
		    llAlready = .t.
		    EXIT
		  ENDIF
		ENDFOR
		
		IF m.llAlready
		  RETURN m.lcFileName
		ENDIF  
		
		THIS.AddTemplate(m.lcFileName)
		
		RETURN m.lcFileName
		          
	ENDPROC

	PROCEDURE getyourfxutesttocopy
		*  
		*  called from THIS.cmdCopyExistingPRG.Click()
		*
		
		LOCAL lcFileName, xx, llAlready
		
		lcFileName = GETFILE("PRG","FoxUnit test class","Select",0,"Select an existing FoxUnit test class .PRG")
		
		IF EMPTY(m.lcFileName)
		  RETURN
		ENDIF
		
		IF NOT THIS.ValidTemplateFile(m.lcFileName)
		  MESSAGEBOX(JUSTFNAME(m.lcFileName) + ;
		             " is not a FoxUnit test case class inheriting from FXUTestCase.PRG", ;
		             48, ;
		             "Please Note")
		  RETURN
		ENDIF
		
		RETURN m.lcFileName
		          
	ENDPROC

	PROCEDURE Init
		*
		*    tcNewTestClass (R) The filename of the new test class
		*                       .PRG to be created here
		*
		*  tcResultVariable (R) The name of the private (or public) variable
		*                       that has already been declared and 
		*                       initialized in the calling code -- it
		*                       will be updated here to either
		*                                  .NULL. - the user <Cancel>led from here
		*                       Fullpath+FileName - the user made a valid selection here
		*
		LPARAMETERS tcNewTestClass, tcResultVariable
		
		THIS.icNewTestClass = m.tcNewTestClass
		THIS.icResultVariable = m.tcResultVariable
		
		THIS.MinHeight = THIS.Height
		THIS.MinWidth = THIS.Width
		
		IF VERSION(5) < 900
		  THIS.BorderStyle = 2
		ENDIF
		
		THIS.RestoreSettings()
		
		THIS.RemoveMissingTemplates()
		
		THIS.AddVMPTemplates()
		
		*
		*  if you subclass this form, you can add code here
		*  to add your own custom templates
		*
		THIS.AddCustomTemplates()
		
		
		
		
		
	ENDPROC

	PROCEDURE Load
		*
		*  grab these settings from the calling FXU.VCX/frmFoxUnit form
		*
		
		THIS.AddProperty("icPersistFile",SPACE(0))
		THIS.AddProperty("icUserID",SPACE(0))
		
		IF TYPE("_Screen.ActiveForm.icPersistFile") = "C" ;
		     AND NOT EMPTY(_Screen.ActiveForm.icPersistFile)
		
		  *
		  *  this should always be true, because this dialog
		  *  is expected to only be called from the main
		  *  FXU.VCX/frmFoxUnit form
		  *
		
		  THIS.icPersistFile = ;
		       ADDBS(JUSTPATH(_Screen.ActiveForm.icPersistFile)) + ;
		       "FXUPersistGetTemplate.XML"
		
		  THIS.icUserID = _Screen.ActiveForm.icUserID
		
		 ELSE
		  *
		  *  this should never really happen, except perhaps
		  *  for when Drew is testing standalone 
		  *
		
		  THIS.icPersistFile = ADDBS(JUSTPATH(FULLPATH("FXUResults.DBF"))) + ;
		       "FXUPersistGetTemplate.XML"
		  
		  THIS.icUserID = ALLTRIM(TRANSFORM(SYS(0)))
		  IF LENC(THIS.icUserID) < 15 OR NOT "#" $ THIS.icUserID
		    *  machine information not assigned by the network,
		    *  or network shell not loaded, or standalone machine
		    THIS.icUserID = SPACE(0)
		   ELSE
		    THIS.icUserID = ALLTRIM(SUBSTRC(THIS.icUserID,AT_C("#",THIS.icUserID)+1))
		  ENDIF
		
		ENDIF
		    
		     
		*
		*  save these for use in THIS.SaveSettings
		*
		THIS.AddProperty("inDesignHeight",THIS.Height)
		THIS.AddProperty("inDesignWidth",THIS.Width)
		     
	ENDPROC

	PROCEDURE modifytemplate
		*
		*  called from THIS.lstTemplates.RightClick()
		*
		
		LOCAL lcFileName
		lcFileName = THIS.iaTemplates[THIS.lstTemplates.Value,3]
		IF EMPTY(m.lcFileName)
		  MESSAGEBOX("This feature is only available for those " + ;
		             "items for which a filename has been specified.", ;
		             48, ;
		             "Please Note")
		  RETURN
		ENDIF
		             
		MODIFY COMMAND (m.lcFileName)
		             
	ENDPROC

	PROCEDURE removemissingtemplates
		*
		*  remove any rows of THIS.lstTemplates that have
		*  been added by THIS.RestoreSettings(), but which
		*  templates are now missing
		*
		
		LOCAL xx, lnRows, lnRemoved, lnValue
		lnRows = ALEN(THIS.iaTemplates,1)
		lnValue = THIS.lstTemplates.Value
		
		IF m.lnRows < 5
		  *  nothing to do
		  RETURN
		ENDIF
		
		lnRemoved = 0
		FOR xx = lnRows TO 5 STEP -1
		  IF NOT FILE(THIS.iaTemplates[m.xx,3])
		    lnRemoved = m.lnRemoved + 1
		    ADEL(THIS.iaTemplates,m.xx)
		  ENDIF
		ENDFOR
		IF m.lnRemoved > 0
		  DIMENSION THIS.iaTemplates[m.lnRows-m.lnRemoved,ALEN(THIS.iaTemplates,2)]
		  THIS.lstTemplates.RowSource = THIS.lstTemplates.RowSource
		  THIS.lstTemplates.Value = 1
		ENDIF
		
		
		
	ENDPROC

	PROCEDURE removetemplate
		*
		*  called from THIS.lstTemplates.RightClick()
		*
		
		IF THIS.iaTemplates[THIS.lstTemplates.Value,4] 
		  MESSAGEBOX("This is a permanent item and may not be removed." + ;
		             CHR(13) + CHR(13) + ;
		             "You may only remove any custom templates of your own.", ;
		             48, ;
		             "Please Note")
		  RETURN
		ENDIF
		
		IF MESSAGEBOX("Are you sure you want to remove " + THIS.iaTemplates[THIS.lstTemplates.Value,2] + "?", ;
		              4+48, ;
		              "Please confirm") = 7
		  RETURN
		ENDIF              
		
		LOCAL lnRow
		lnRow = THIS.lstTemplates.Value
		ADEL(THIS.iaTemplates,m.lnRow)
		DIMENSION THIS.iaTemplates[ALEN(THIS.iaTemplates,1)-1,ALEN(THIS.iaTemplates,2)]
		IF m.lnRow > ALEN(THIS.iaTemplates,1)
		 THIS.lstTemplates.Value = THIS.lstTemplates.Value-1
		ENDIF
		THIS.lstTemplates.RowSource = THIS.lstTemplates.RowSource
		
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE restoresettings
		*
		*  restore settings from the last time this
		*  form was run
		*
		*  this method is called from THIS.Init()
		*
		LOCAL lcUserID, lcCommand, lcAlias
		
		lcUserID = THIS.icUserID
		lcAlias = SYS(2015)
		
		IF FILE(THIS.icPersistFile)
		  TRY 
		  XMLTOCURSOR(THIS.icPersistFile,m.lcAlias,512)
		  *
		  *  apply settings for this user/developer
		  *
		  SELECT (m.lcAlias)
		  LOCATE
		  SCAN FOR UPPER(ALLTRIM(UserID)) == UPPER(ALLTRIM(THIS.icUserID))
		    lcCommand = ALLTRIM(Setting)
		    &lcCommand
		    SELECT (m.lcAlias)
		  ENDSCAN
		  CATCH TO loException
		  ENDTRY
		  USE IN SELECT(m.lcAlias)
		ENDIF
		
		RETURN 
		
		 
	ENDPROC

	PROCEDURE savesettings
		*
		*  save settings so they can be restored the next
		*  time this form is run (see THIS.Init() call to
		*  THIS.RestoreSettings() method)
		*
		*  this method is called from THIS.Destroy()
		*
		
		LOCAL lcAlias
		lcAlias = "FXUPersistGetTemplate"   &&& SYS(2015)
		
		TRY
		
		IF FILE(THIS.icPersistFile)
		  XMLTOCURSOR(THIS.icPersistFile,m.lcAlias,512)
		 ELSE
		  CREATE CURSOR (m.lcAlias) (UserID C(10), Setting M)
		ENDIF
		SELECT (m.lcAlias)
		*
		*  delete all the existing settings for this user
		*
		DELETE ALL FOR UPPER(ALLTRIM(UserID)) == UPPER(ALLTRIM(THIS.icUserID))
		SCATTER MEMVAR 
		m.UserID = THIS.icUserID
		
		*
		*  THISFORM settings
		*
		m.Setting = "THIS.Top = " + TRANSFORM(THIS.Top)
		INSERT INTO (m.lcAlias) FROM MEMVAR 
		m.Setting = "THIS.Left = " + TRANSFORM(THIS.Left) 
		INSERT INTO (m.lcAlias) FROM MEMVAR 
		m.Setting = "THIS.Height = IIF(VERSION(5)>=900," + TRANSFORM(THIS.Height) + "," + TRANSFORM(THIS.inDesignHeight) + ")"
		INSERT INTO (m.lcAlias) FROM MEMVAR 
		m.Setting = "THIS.Width = IIF(VERSION(5)>=900," + TRANSFORM(THIS.Width) + "," + TRANSFORM(THIS.inDesignWidth) + ")"
		INSERT INTO (m.lcAlias) FROM MEMVAR 
		
		*
		*  THISFORM checkbox values
		*
		m.Setting = "THIS.chkProcedure.Value = " + TRANSFORM(THIS.chkProcedure.Value)
		INSERT INTO (m.lcAlias) FROM MEMVAR 
		m.Setting = "THIS.chkTab.Value = " + TRANSFORM(THIS.chkTab.Value)
		INSERT INTO (m.lcAlias) FROM MEMVAR 
		
		*
		*  THIS.lstTemplates.Value
		*
		m.Setting = "THIS.lstTemplates.Value = " + TRANSFORM(THIS.lstTemplates.Value)
		INSERT INTO (m.lcAlias) FROM MEMVAR 
		
		*
		*  all templates after the permanent templates
		*
		
		IF ALEN(THIS.iaTemplates,1) > THIS.inPermanentTemplates
		  m.Setting = 'DIMENSION THIS.iaTemplates[' + TRANSFORM(ALEN(THIS.iaTemplates,1)) + ',' + TRANSFORM(ALEN(THIS.iaTemplates,2)) + ']'
		  INSERT INTO (m.lcAlias) FROM MEMVAR 
		  LOCAL xx, yy
		  FOR xx = THIS.inPermanentTemplates+1 TO ALEN(THIS.iaTemplates,1)
		    IF EMPTY(THIS.iaTemplates[m.xx,2]) OR NOT FILE(THIS.iaTemplates[m.xx,3])
		      LOOP 
		    ENDIF
		    FOR yy = 1 TO ALEN(THIS.iaTemplates,2)-1
		      m.Setting = 'THIS.iaTemplates[' + TRANSFORM(m.xx) + ',' + TRANSFORM(m.yy) + '] = "' + TRANSFORM(THIS.iaTemplates[m.xx,m.yy]) + ["]
		      INSERT INTO (m.lcAlias) FROM MEMVAR 
		    ENDFOR
		    m.Setting = 'THIS.iaTemplates[' + TRANSFORM(m.xx) + ',' + TRANSFORM(ALEN(THIS.iaTemplates,2)) + '] = ' + TRANSFORM(THIS.iaTemplates[m.xx,m.yy]) 
		    INSERT INTO (m.lcAlias) FROM MEMVAR 
		  ENDFOR
		  m.Setting = "THIS.lstTemplates.RowSource = THIS.lstTemplates.RowSource"
		  INSERT INTO (m.lcAlias) FROM MEMVAR 
		ENDIF
		
		CURSORTOXML(m.lcAlias,THIS.icPersistFile,1,512,0,"1")
		
		CATCH TO loException
		ENDTRY
		
		USE IN SELECT(m.lcAlias)
		
		IF VARTYPE(m.loException) = "O"
		  MESSAGEBOX("Unable to save user settings because " + ;
		             CHR(13) + ;
		             loException.Message, ;
		             48, ;
		             "Please Note")
		ENDIF
		
		RETURN
		
	ENDPROC

	PROCEDURE sortoptionaltemplates
		*
		*  re-sort the optional templates, in alphabetical order
		*  
		
		IF ALEN(THIS.iaTemplates,1) = THIS.inPermanentTemplates
		  *  nothing to do
		  RETURN
		ENDIF
		
		LOCAL lnRows, lnCols, lnPermanentRows, xx, yy, lnRow
		lnRows = ALEN(THIS.iaTemplates,1)
		lnCols = ALEN(THIS.iaTemplates,2)
		lnPermanentRows = THIS.inPermanentTemplates
		
		LOCAL laItems[m.lnRows-THIS.inPermanentTemplates,m.lnCols]
		
		FOR xx = lnPermanentRows+1 TO m.lnRows
		  FOR yy = 1 TO m.lnCols
		    laItems[m.xx-m.lnPermanentRows,m.yy] = THIS.iaTemplates[m.xx,m.yy]
		  ENDFOR
		ENDFOR
		
		ASORT(laItems)
		
		FOR xx = m.lnPermanentRows+1 TO m.lnRows
		  FOR yy = 1 TO m.lnCols
		    THIS.iaTemplates[m.xx,m.yy] = laItems[m.xx-m.lnPermanentRows,m.yy]
		  ENDFOR
		ENDFOR
		
		*lnRow = ASCAN(THISFORM.iaTemplates,m.lcFileName,3,-1,3,15)
		
		
	ENDPROC

	PROCEDURE templateclassinheritsfromfxutestcase
		LPARAMETERS tcDefineClassStatement
		
		LOCAL lcTestCaseClass, lcTestCaseClassProgramFile
		
		m.tcDefineClassStatement = UPPER(ALLTRIM( m.tcDefineClassStatement ))
		
		m.tcDefineClassStatement = SUBSTR( m.tcDefineClassStatement, ;
			ATC( " AS", m.tcDefineClassStatement ) + 3)
			
		m.lcTestCaseClass = ALLTRIM(LEFT(m.tcDefineClassStatement, ;
			ATC("OF", m.tcDefineClassStatement) - 1)) 
		
		m.lcTestCaseClassProgramFile = ALLTRIM(SUBSTR(m.tcDefineClassStatement, ;
			RATC(SPACE(1), m.tcDefineClassStatement))) 	
			
		RETURN  FXUInheritsFromFxuTestCase( m.lcTestCaseClass, m.lcTestCaseClassProgramFile )  
			
		 
	ENDPROC

	PROCEDURE Unload
		LOCAL lcResultVariable
		lcResultVariable = THIS.icResultVariable
		STORE THIS.iuRetVal TO &lcResultVariable
		
		RETURN THIS.iuRetVal
		
	ENDPROC

	PROCEDURE validatederivedtestcasetemplate
		LPARAMETERS tcTestCaseTemplate
		
		LOCAL llValidDerivedTestCaseTemplate
		LOCAL lcValidatePrg, lnLInes
		LOCAL ARRAY laLines[1]
		
		llValidDerivedTestCaseTemplate = .f. 
		
		DO WHILE .t.
		
			IF !FILE(tcTestCaseTemplate)
				EXIT 
			ENDIF
			
			
			
			
			
			
			
			
		
		
			EXIT 
		ENDDO 
		
		RETURN llValidDerivedTestCaseTemplate
	ENDPROC

	PROCEDURE validtemplatefile
		*
		*  RETURNs a logical value indicating whether the
		*  passed tcFileName is a valid FXUTestCase template
		*
		LPARAMETERS tcFileName
		
		LOCAL laLines[1], lcLine, llValid
		=ALINES(laLines,FILETOSTR(m.tcFileName),.t.)
		FOR EACH lcLine IN laLines
		*  IF UPPER(ALLTRIM(m.lcLine)) = "DEFINE CLASS " ;
		*      AND UPPER(" AS FXUTestCase OF FXUTestCase") $ UPPER(m.lcLine)
		
		  IF UPPER(ALLTRIM(m.lcLine)) = "DEFINE CLASS " ;
		  	AND (UPPER(" AS FXUTestCase OF FXUTestCase") $ UPPER(m.lcLine) ;
			OR this.TemplateClassInheritsFromFxuTestCase(m.lcLine))
		
		    *
		    *  MODIFY COMMAND FXUTestCase 
		    *  MODIFY COMMAND FXUTestCaseTemplate.TXT
		    *    XXDTES("FXUTESTCASETEMPLATE.TXT","DEFINE CLASS")
		    *
		    IF UPPER(JUSTEXT(m.tcFileName)) = "TXT"
		      *  make sure it has the <<test class>> text
		      llValid = "<<" $ m.lcLine ;
		                AND ">>" $ m.lcLine ;
		                AND AT_C("<<",m.lcLine) < AT_C(">>",m.lcLine)
		     ELSE
		      *  PRG
		      llValid = .t.
		    ENDIF
		    IF m.llValid
		      EXIT
		    ENDIF
		  ENDIF         
		ENDFOR
		
		RETURN m.llValid
		
		
		
		
	ENDPROC

	PROCEDURE zreadme
		#IF .f.
		
		Class:  FXU.VCX/frmGetTestClassTemplate
		
		
		#ENDIF
	ENDPROC

	PROCEDURE chkProcedure.Init
		IF VERSION(5)>=900
		  *
		  *  2 = Left Absolute
		  *  4 = Bottom Absolute
		  *
		  THIS.Anchor = 2 + 4
		ENDIF
	ENDPROC

	PROCEDURE chkProcedure.Refresh
		THIS.Enabled = THISFORM.lstTemplates.Value < 3
		
		
	ENDPROC

	PROCEDURE chkTab.Init
		IF VERSION(5)>=900
		  *
		  *  2 = Left Absolute
		  *  4 = Bottom Absolute
		  *
		  THIS.Anchor = 2 + 4
		ENDIF
	ENDPROC

	PROCEDURE chkTab.Refresh
		THIS.Enabled = THISFORM.lstTemplates.Value < 3
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		THISFORM.Release()
	ENDPROC

	PROCEDURE cmdCancel.Init
		IF VERSION(5)>=900
		  *
		  *  4 = Bottom Absolute
		  *  8 = Right Absolute
		  *
		  THIS.Anchor = 8 + 4
		ENDIF
	ENDPROC

	PROCEDURE cmdCopyExistingPRG.Click
		LOCAL lcTemplateFile
		
		lcTemplateFile = THISFORM.GetYourFXUTestToCopy()
		
		IF NOT VARTYPE(m.lcTemplateFile) = "C" OR EMPTY(m.lcTemplateFile)
		  RETURN
		ENDIF
		
		THISFORM.iuRetVal = m.lcTemplateFile + ",.NULL.,.NULL."
		
		THISFORM.Release()
		
		
	ENDPROC

	PROCEDURE cmdCopyExistingPRG.Init
		IF VERSION(5)>=900
		  *
		  *  4 = Bottom Absolute
		  *  8 = Right Absolute
		  *  2 = Left Absolute
		  *
		  THIS.Anchor = 2 + 8 + 4
		ENDIF
		
	ENDPROC

	PROCEDURE cmdSelectCustomTemplate.Click
		LOCAL lcTemplateFile
		
		lcTemplateFile = THISFORM.GetYourFXUTemplate()
		
		IF NOT VARTYPE(m.lcTemplateFile) = "C" OR EMPTY(m.lcTemplateFile)
		  RETURN
		ENDIF
		
		THISFORM.iuRetVal = m.lcTemplateFile + ",.NULL.,.NULL."
		
		THISFORM.Release()
		
		
	ENDPROC

	PROCEDURE cmdSelectCustomTemplate.Init
		IF VERSION(5)>=900
		  *
		  *  4 = Bottom Absolute
		  *  8 = Right Absolute
		  *  2 = Left Absolute
		  *
		  THIS.Anchor = 2 + 8 + 4
		ENDIF
		
	ENDPROC

	PROCEDURE cmdSelectTemplate.Click
		LOCAL lcTemplateFile
		
		IF FILE(THISFORM.iaTemplates[THISFORM.lstTemplates.Value,3])
		  lcTemplateFile = THISFORM.iaTemplates[THISFORM.lstTemplates.Value,3]
		 ELSE
		  IF MESSAGEBOX("Unable to locate " + ;
		                CHR(13) + ;
		                THISFORM.iaTemplates[THISFORM.lstTemplates.Value,3] + ;
		                CHR(13) + CHR(13) + ;
		                "Remove it from the list?", ;
		                16 + 4, ;
		                "Please Note") = 6
		    THISFORM.RemoveTemplate()
		  ENDIF 
		  RETURN .f.                   
		ENDIF
		
		THISFORM.iuRetVal = m.lcTemplateFile + "," 
		IF THISFORM.lstTemplates.Value > 2
		  THISFORM.iuRetVal = THISFORM.iuRetVal + ".NULL.,.NULL."
		 ELSE
		  THISFORM.iuRetVal = THISFORM.iuRetVal + ;
		                  IIF(THISFORM.chkProcedure.Value,"PROCEDURE","FUNCTION") + ;
		                  "," + ;
		                  IIF(THISFORM.chkTab.Value,"TABS","NOTABS")
		ENDIF
		
		THISFORM.Release()
		
		
		
	ENDPROC

	PROCEDURE cmdSelectTemplate.Init
		IF VERSION(5)>=900
		  *
		  *  4 = Bottom Absolute
		  *  8 = Right Absolute
		  *  2 = Left Absolute
		  *
		  THIS.Anchor = 2 + 8 + 4
		ENDIF
		
		
	ENDPROC

	PROCEDURE lblCancel.Init
		IF VERSION(5)>=900
		  *
		  *  4 = Bottom Absolute
		  *  8 = Right Absolute
		  *
		  THIS.Anchor = 8 + 4
		ENDIF
	ENDPROC

	PROCEDURE lblOR1.Init
		IF VERSION(5)>=900
		  *
		  *  4 = Bottom Absolute
		  *  2 = Left Absolute
		  *
		  THIS.Anchor = 4 + 2
		ENDIF
	ENDPROC

	PROCEDURE lblOR2.Init
		IF VERSION(5)>=900
		  *
		  *  4 = Bottom Absolute
		  *  2 = Left Absolute
		  *
		  THIS.Anchor = 4 + 2
		ENDIF
	ENDPROC

	PROCEDURE lstTemplates.Init
		LOCAL lnRow, lnCols
		lnRow = 0
		lnCols = 4
		
		lnRow = m.lnRow + 1
		DIMENSION THISFORM.iaTemplates[m.lnRow,m.lnCols]
		THISFORM.iaTemplates[m.lnRow,1] = "Standard FoxUnit test case template"
		THISFORM.iaTemplates[m.lnRow,2] = "FXUTestCaseTemplate.TXT"
		THISFORM.iaTemplates[m.lnRow,3] = FULLPATH(THISFORM.iaTemplates[m.lnRow,2])
		THISFORM.iaTemplates[m.lnRow,4] = .t.   &&& permanent
		
		lnRow = m.lnRow + 1
		DIMENSION THISFORM.iaTemplates[m.lnRow,m.lnCols]
		THISFORM.iaTemplates[m.lnRow,1] = "Minimal FoxUnit test case template"
		THISFORM.iaTemplates[m.lnRow,2] = "FXUTestCaseTemplate_Minimal.TXT"
		THISFORM.iaTemplates[m.lnRow,3] = FULLPATH(THISFORM.iaTemplates[m.lnRow,2])
		THISFORM.iaTemplates[m.lnRow,4] = .t.   &&& permanent
		
		THISFORM.inPermanentTemplates = ALEN(THISFORM.iaTemplates,1)
		
		THIS.RowSourceType = 5
		THIS.RowSource = "THISFORM.iaTemplates"
		
		THIS.Value = 1
		
		IF VERSION(5)>=900
		  *
		  *    1 = Top Absolute
		  *    2 = Left Absolute
		  *  128 = Right Relative
		  *    4 = Bottom Absolute
		  *
		  THIS.Anchor = 1 + 2 + 128 + 4
		ENDIF
		
		
	ENDPROC

	PROCEDURE lstTemplates.InteractiveChange
		THISFORM.Refresh()
		
	ENDPROC

	PROCEDURE lstTemplates.RightClick
		DEFINE POPUP pShortCut IN WINDOW (THISFORM.Name) SHORTCUT RELATIVE FROM MROW(THISFORM.Name),MCOL(THISFORM.Name)
		
		DEFINE BAR 1 OF pShortCut PROMPT "MODIFY COMMAND the indicated template" 
		ON SELECTION BAR 1 OF pShortCut _Screen.ActiveForm.ModifyTemplate() 
		
		DEFINE BAR 2 OF pShortCut PROMPT "Add a template file to this list" 
		ON SELECTION BAR 2 OF pShortCut _Screen.ActiveForm.AddTemplate() 
		
		DEFINE BAR 3 OF pShortCut PROMPT "Remove this template from the list" 
		ON SELECTION BAR 3 OF pShortCut _Screen.ActiveForm.RemoveTemplate() 
		
		ACTIVATE POPUP pShortCut
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmoptions AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="pgfOptions" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.chkAllowDebug" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label15" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label16" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label17" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label18" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label19" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label20" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label21" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label22" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label24" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.Label23" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagDebugging.chkCloseDebuggerAfterTestsRun" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagInterface.shpColor" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagInterface.chkShowTips" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagInterface.chkReloadAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagInterface.chkHonorTestPrefix" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagInterface.chkResetColors" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagInterface.lblColors" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagInterface.lblPass" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagInterface.lblFail" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagInterface.shpPass" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagInterface.shpFail" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagAbout.Check1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagAbout.Check2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagAbout.Check3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagAbout.Check4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagAbout.edtDocument" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagTools.txtCompareTool" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagTools.cmdSelectFile" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagTools.Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagTools.Label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfOptions.pagTools.txtCompareParameters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: okaction
		*m: showdocument
		*m: zreadme
		*p: ilinitialhonortestprefix
		*p: iomainform
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	AllowOutput = .F.
	AutoCenter = .T.
	Caption = "Customize FoxUnit options"
	ControlBox = .F.
	DoCreate = .T.
	Height = 421
	Icon = ..\
	iomainform = .NULL.
	MaxButton = .F.
	MinButton = .F.
	Name = "frmoptions"
	ShowTips = .T.
	ShowWindow = 1
	Width = 664
	WindowType = 1
	_memberdata = <VFPData>
		<memberdata name="showdocument" display="showDocument"/>
		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		Cancel = .T., ;
		Caption = "\<Cancel", ;
		FontName = "Tahoma", ;
		Height = 39, ;
		Left = 572, ;
		Name = "cmdCancel", ;
		Picture = ("FXUCancel.BMP"), ;
		TabIndex = 5, ;
		ToolTipText = "Click here to cancel the changes you have made here", ;
		Top = 371, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOK' AS commandbutton WITH ;
		Caption = "\<OK", ;
		Default = .T., ;
		FontName = "Tahoma", ;
		Height = 39, ;
		Left = 476, ;
		Name = "cmdOK", ;
		Picture = ("FXUFormClose.BMP"), ;
		TabIndex = 5, ;
		ToolTipText = "Click here to make permanent the settings you update here", ;
		Top = 371, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'Label1' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Select OK to make permanent any changes you make here.  The settings are persisted in FXUPersist.XML, located in the same folder as the FXUResults.DBF", ;
		Height = 32, ;
		Left = 8, ;
		Name = "Label1", ;
		Top = 375, ;
		Width = 444, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions' AS pageframe WITH ;
		ErasePage = .T., ;
		Height = 352, ;
		Left = 8, ;
		Name = "pgfOptions", ;
		PageCount = 4, ;
		Themes = .F., ;
		Top = 8, ;
		Width = 652, ;
		Page1.Caption = "Debugging", ;
		Page1.Name = "pagDebugging", ;
		Page1.PageOrder = 1, ;
		Page2.Caption = "Interface", ;
		Page2.Name = "pagInterface", ;
		Page2.PageOrder = 2, ;
		Page3.Caption = "About", ;
		Page3.Name = "pagAbout", ;
		Page3.PageOrder = 4, ;
		Page4.Caption = "Tools", ;
		Page4.Name = "pagTools", ;
		Page4.PageOrder = 3
		*< END OBJECT: BaseClass="pageframe" />

	ADD OBJECT 'pgfOptions.pagAbout.Check1' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .F., ;
		Caption = "Getting Started", ;
		Comment = "readme.md", ;
		Height = 43, ;
		Left = 2, ;
		Name = "Check1", ;
		Picture = ..\graphics\foxunit.bmp, ;
		PicturePosition = 0, ;
		Style = 1, ;
		Top = 12, ;
		Width = 142
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'pgfOptions.pagAbout.Check2' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .F., ;
		Caption = "Version History", ;
		Comment = "versions.md", ;
		Height = 43, ;
		Left = 2, ;
		Name = "Check2", ;
		Picture = ..\graphics\foxunit.bmp, ;
		PicturePosition = 0, ;
		Style = 1, ;
		Top = 53, ;
		Width = 142
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'pgfOptions.pagAbout.Check3' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .F., ;
		Caption = "Acknowledgements", ;
		Comment = "foxunitacknowledgements.md", ;
		Height = 43, ;
		Left = 2, ;
		Name = "Check3", ;
		Picture = ..\graphics\foxunit.bmp, ;
		PicturePosition = 0, ;
		Style = 1, ;
		Top = 95, ;
		Width = 142
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'pgfOptions.pagAbout.Check4' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .F., ;
		Caption = "License", ;
		Comment = "foxunitlicense.md", ;
		Height = 43, ;
		Left = 2, ;
		Name = "Check4", ;
		Picture = ..\graphics\foxunit.bmp, ;
		PicturePosition = 0, ;
		Style = 1, ;
		Top = 136, ;
		Width = 142
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'pgfOptions.pagAbout.edtDocument' AS editbox WITH ;
		BackColor = 255,255,255, ;
		DisabledBackColor = 255,255,255, ;
		Height = 301, ;
		Left = 147, ;
		Name = "edtDocument", ;
		ReadOnly = .T., ;
		Top = 12, ;
		Width = 493
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'pgfOptions.pagDebugging.chkAllowDebug' AS checkbox WITH ;
		Alignment = 0, ;
		BackStyle = 0, ;
		Caption = "Exclude the Setup() and TearDown() methods from the TRY..CATCH block in which each test executes", ;
		Height = 17, ;
		Left = 15, ;
		Name = "chkAllowDebug", ;
		Top = 25, ;
		Width = 576
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'pgfOptions.pagDebugging.chkCloseDebuggerAfterTestsRun' AS checkbox WITH ;
		Alignment = 0, ;
		BackStyle = 0, ;
		Caption = "Automatically close the debugger at completion of test suite run (all, class or selected)", ;
		Height = 17, ;
		Left = 15, ;
		Name = "chkCloseDebuggerAfterTestsRun", ;
		ToolTipText = "If left unchecked, all class methods not implemented in the superclass of the test class will be loaded and run as tests. For a more detailed explanation, read the comments on icTestPrefix in FxuTestCaseTemplate.txt", ;
		Top = 5, ;
		Value = .F., ;
		Width = 576
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label1' AS label WITH ;
		BackStyle = 0, ;
		Caption = "As shown on the left, the default FoxUnit behavior is to execute any explicit Setup() code for the test class, run the test, then execute any explicit TearDown() code for that test class -- all within the TRY..CATCH block.", ;
		Height = 32, ;
		Left = 15, ;
		Name = "Label1", ;
		Top = 49, ;
		Width = 616, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label10' AS label WITH ;
		BackStyle = 0, ;
		Caption = "FINALLY", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 71, ;
		Name = "Label10", ;
		Top = 165, ;
		Width = 168
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label11' AS label WITH ;
		BackStyle = 0, ;
		Caption = "CATCH TO loEx", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 79, ;
		Name = "Label11", ;
		Top = 201, ;
		Width = 168
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label12' AS label WITH ;
		BackStyle = 0, ;
		Caption = "THIS.HandleException(...)", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 87, ;
		Name = "Label12", ;
		Top = 213, ;
		Width = 176
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label13' AS label WITH ;
		BackStyle = 0, ;
		Caption = "ENDTRY", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 79, ;
		Name = "Label13", ;
		Top = 225, ;
		Width = 176
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label14' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Errors in Setup() and TearDown() methods are handled -- no native VFP Cancel/Ignore/Suspend dialog.", ;
		FontItalic = .T., ;
		Height = 16, ;
		Left = 15, ;
		Name = "Label14", ;
		Top = 81, ;
		Width = 588
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label15' AS label WITH ;
		BackStyle = 0, ;
		Caption = "As shown on the right, if you select the checkbox above, there is no TRY..CATCH exception handling for the Setup() and TearDown() code.", ;
		Height = 32, ;
		Left = 15, ;
		Name = "Label15", ;
		Top = 261, ;
		Width = 620, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label16' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Errors in Setup() and TearDown() methods invoked the native VFP Cancel/Ignore/Suspend dialog.", ;
		FontItalic = .T., ;
		Height = 16, ;
		Left = 15, ;
		Name = "Label16", ;
		Top = 293, ;
		Width = 556
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label17' AS label WITH ;
		BackStyle = 0, ;
		Caption = "TRY", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 379, ;
		Name = "Label17", ;
		Top = 125, ;
		Width = 168
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label18' AS label WITH ;
		BackStyle = 0, ;
		Caption = "THIS.Setup()", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 379, ;
		Name = "Label18", ;
		Top = 105, ;
		Width = 168
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label19' AS label WITH ;
		BackStyle = 0, ;
		Caption = "THIS.RunTest()", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 387, ;
		Name = "Label19", ;
		Top = 137, ;
		Width = 168
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label2' AS label WITH ;
		BackStyle = 0, ;
		Caption = "TRY", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 71, ;
		Name = "Label2", ;
		Top = 105, ;
		Width = 168
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label20' AS label WITH ;
		BackStyle = 0, ;
		Caption = "CATCH TO loEx", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 379, ;
		Name = "Label20", ;
		Top = 149, ;
		Width = 168
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label21' AS label WITH ;
		BackStyle = 0, ;
		Caption = "THIS.HandleException(...)", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 387, ;
		Name = "Label21", ;
		Top = 161, ;
		Width = 176
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label22' AS label WITH ;
		BackStyle = 0, ;
		Caption = "ENDTRY", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 379, ;
		Name = "Label22", ;
		Top = 173, ;
		Width = 176
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label23' AS label WITH ;
		BackStyle = 0, ;
		Caption = "(This is the behavior you get if you select the above checkbox)", ;
		FontItalic = .T., ;
		Height = 32, ;
		Left = 387, ;
		Name = "Label23", ;
		Top = 217, ;
		Width = 180, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label24' AS label WITH ;
		BackStyle = 0, ;
		Caption = "THIS.TearDown()", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 379, ;
		Name = "Label24", ;
		Top = 193, ;
		Width = 168
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label3' AS label WITH ;
		BackStyle = 0, ;
		Caption = "THIS.Setup()", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 79, ;
		Name = "Label3", ;
		Top = 117, ;
		Width = 168
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label4' AS label WITH ;
		BackStyle = 0, ;
		Caption = "THIS.RunTest()", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 79, ;
		Name = "Label4", ;
		Top = 129, ;
		Width = 168
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label5' AS label WITH ;
		BackStyle = 0, ;
		Caption = "CATCH TO loEx", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 71, ;
		Name = "Label5", ;
		Top = 141, ;
		Width = 168
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label6' AS label WITH ;
		BackStyle = 0, ;
		Caption = "THIS.HandleException(...)", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 79, ;
		Name = "Label6", ;
		Top = 153, ;
		Width = 176
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label7' AS label WITH ;
		BackStyle = 0, ;
		Caption = "ENDTRY", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 71, ;
		Name = "Label7", ;
		Top = 237, ;
		Width = 176
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label8' AS label WITH ;
		BackStyle = 0, ;
		Caption = "TRY", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 79, ;
		Name = "Label8", ;
		Top = 177, ;
		Width = 168
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Label9' AS label WITH ;
		BackStyle = 0, ;
		Caption = "THIS.TearDown()", ;
		FontName = "Courier New", ;
		Height = 16, ;
		Left = 87, ;
		Name = "Label9", ;
		Top = 189, ;
		Width = 168
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagDebugging.Shape1' AS shape WITH ;
		BackColor = 255,255,255, ;
		BorderColor = 255,255,255, ;
		Height = 157, ;
		Left = 55, ;
		Name = "Shape1", ;
		Top = 101, ;
		Width = 225
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'pgfOptions.pagDebugging.Shape2' AS shape WITH ;
		BackColor = 255,255,255, ;
		BorderColor = 255,255,255, ;
		Height = 157, ;
		Left = 363, ;
		Name = "Shape2", ;
		Top = 101, ;
		Width = 225
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'pgfOptions.pagInterface.chkHonorTestPrefix' AS checkbox WITH ;
		Alignment = 0, ;
		BackStyle = 0, ;
		Caption = "Load and run only tests with the specified icTestPrefix value in test classes", ;
		Height = 17, ;
		Left = 31, ;
		Name = "chkHonorTestPrefix", ;
		TabIndex = 3, ;
		ToolTipText = "If left unchecked, all class methods not implemented in the superclass of the test class will be loaded and run as tests. For a more detailed explanation, read the comments on icTestPrefix in FxuTestCaseTemplate.txt", ;
		Top = 62, ;
		Value = .T., ;
		Width = 428
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'pgfOptions.pagInterface.chkReloadAll' AS checkbox WITH ;
		Alignment = 0, ;
		BackStyle = 0, ;
		Caption = "Reload all test classes involved in a test run every time tests are run", ;
		Height = 17, ;
		Left = 31, ;
		Name = "chkReloadAll", ;
		TabIndex = 2, ;
		ToolTipText = "This will mean a performance hit each time tests are run, and could also affect cursor positioning in the grid, however if you modify tests outside of the buttons provided by the FoxUnit form, this may be a wise choice.", ;
		Top = 43, ;
		Value = .F., ;
		Width = 428
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'pgfOptions.pagInterface.chkResetColors' AS checkbox WITH ;
		Alignment = 0, ;
		BackStyle = 0, ;
		Caption = "Clear colors showing results from previous test runs on new run", ;
		Height = 17, ;
		Left = 35, ;
		Name = "chkResetColors", ;
		TabIndex = 5, ;
		ToolTipText = "If checked, background color showing previous test result runs will be reset when any new test(s) is run", ;
		Top = 176, ;
		Value = .T., ;
		Width = 428
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'pgfOptions.pagInterface.chkShowTips' AS checkbox WITH ;
		Alignment = 0, ;
		BackStyle = 0, ;
		Caption = "Show ToolTipText in the main FoxUnit form (set its ShowTips property to .t.)", ;
		Height = 17, ;
		Left = 31, ;
		Name = "chkShowTips", ;
		TabIndex = 1, ;
		Top = 24, ;
		Value = .T., ;
		Width = 428
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'pgfOptions.pagInterface.lblColors' AS label WITH ;
		Caption = "Colors", ;
		FontBold = .T., ;
		Height = 17, ;
		Left = 34, ;
		Name = "lblColors", ;
		TabIndex = 4, ;
		Top = 100, ;
		Width = 40
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagInterface.lblFail' AS label WITH ;
		Caption = "Fail", ;
		Height = 17, ;
		Left = 87, ;
		Name = "lblFail", ;
		TabIndex = 7, ;
		Top = 150, ;
		Width = 40
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagInterface.lblPass' AS label WITH ;
		Caption = "Pass", ;
		Height = 17, ;
		Left = 87, ;
		Name = "lblPass", ;
		TabIndex = 6, ;
		Top = 126, ;
		Width = 40
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagInterface.shpColor' AS shape WITH ;
		Anchor = 10, ;
		BackStyle = 0, ;
		Height = 107, ;
		Left = 27, ;
		Name = "shpColor", ;
		SpecialEffect = 0, ;
		Top = 96, ;
		Width = 396
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'pgfOptions.pagInterface.shpFail' AS shape WITH ;
		BackStyle = 1, ;
		FillStyle = 0, ;
		Height = 22, ;
		Left = 60, ;
		Name = "shpFail", ;
		Top = 147, ;
		Width = 22
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'pgfOptions.pagInterface.shpPass' AS shape WITH ;
		BackStyle = 1, ;
		FillStyle = 0, ;
		Height = 22, ;
		Left = 60, ;
		Name = "shpPass", ;
		Top = 123, ;
		Width = 22
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'pgfOptions.pagTools.cmdSelectFile' AS commandbutton WITH ;
		Caption = "Select...", ;
		Height = 25, ;
		Left = 571, ;
		Name = "cmdSelectFile", ;
		TabIndex = 2, ;
		Top = 34, ;
		Width = 64, ;
		ZOrderSet = 13
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'pgfOptions.pagTools.Label1' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Configure the tool used for comparing expected and actual values of failed tests", ;
		Height = 15, ;
		Left = 6, ;
		Name = "Label1", ;
		TabIndex = 1, ;
		Top = 9, ;
		Width = 620, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagTools.Label2' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Specify the command line parameters. You can use %1 and %2 as placeholders for the two files. Quotes are added automatically. If you don't specify anything, the default of %1 %2 is used.", ;
		Height = 35, ;
		Left = 6, ;
		Name = "Label2", ;
		TabIndex = 4, ;
		Top = 79, ;
		Width = 620, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'pgfOptions.pagTools.txtCompareParameters' AS textbox WITH ;
		Height = 25, ;
		Left = 11, ;
		Name = "txtCompareParameters", ;
		TabIndex = 5, ;
		Top = 119, ;
		Width = 545, ;
		ZOrderSet = 9
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'pgfOptions.pagTools.txtCompareTool' AS textbox WITH ;
		Height = 25, ;
		Left = 11, ;
		Name = "txtCompareTool", ;
		TabIndex = 3, ;
		TabStop = .F., ;
		Top = 34, ;
		Width = 545, ;
		ZOrderSet = 9
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE Destroy
		THIS.ioMainForm = .NULL.
		
	ENDPROC

	PROCEDURE GotFocus
		KEYBOARD '{TAB}' PLAIN CLEAR 
	ENDPROC

	PROCEDURE Init
		Thisform.MinHeight	= thisform.Height	&& FDBOZZO
		thisform.MinWidth	= thisform.Width	&& FDBOZZO
		
		this.ilInitialHonorTestPrefix = this.ioMainForm.ilHonorTestPrefix
		this.pgfOptions.pagInterface.shpPass.FillColor = thisform.ioMainForm.inColorPass
		this.pgfOptions.pagInterface.shpFail.FillColor = thisform.ioMainForm.inColorFail
		
		
		This.showDocument(ThisForm.pgfOptions.pagAbout.Check1)
	ENDPROC

	PROCEDURE Load
		*
		*  store an object reference to the main calling
		*  FoxUnit form, which calls this form
		*
		THIS.ioMainForm = _Screen.ActiveForm
		
		
	ENDPROC

	PROCEDURE okaction
		* Debugger page options
		THISFORM.ioMainForm.ilCloseDebuggerAtEndOfTestsRun = ;
			this.pgfOptions.pagDebugging.chkCloseDebuggerAfterTestsRun.Value
		THISFORM.ioMainForm.ilAllowDebug = THIS.pgfOptions.pagDebugging.chkAllowDebug.Value
		
		* Interface page options
		THISFORM.ioMainForm.ShowTips = THIS.pgfOptions.pagInterface.chkShowTips.Value
		thisform.ioMainForm.ilHonorTestPrefix = this.pgfOptions.pagInterface.chkHonorTestPrefix.value
		thisform.ioMainForm.ilReloadTestsOnRun = this.pgfOptions.pagInterface.chkReloadAll.Value
		thisform.ioMainForm.iResetResults = this.pgfOptions.pagInterface.chkResetColors.Value
		
		thisform.ioMainForm.inColorPass = this.pgfOptions.pagInterface.shpPass.FillColor
		thisform.ioMainForm.inColorFail = this.pgfOptions.pagInterface.shpFail.FillColor
		
		* Tools page options
		thisform.ioMainForm.icCompareTool = ;
			Alltrim(this.pgfOptions.pagTools.txtCompareTool.Value)
		thisform.ioMainForm.icCompareParameters = ;
			Alltrim(this.pgfOptions.pagTools.txtCompareParameters.Value)
		
		* If we've changed the value of ilHonorTestPrefix, 
		* we need to reload all test case classes
		IF thisform.ioMainForm.ilHonorTestPrefix != thisform.ilInitialhonortestprefix
			thisform.ioMainForm.ioResultData.ReloadTestCaseClasses()
		ENDIF 
		
		
		
		
	ENDPROC

	PROCEDURE showdocument
		LPARAMETERS oCheckBox
		ThisForm.pgfOptions.pagAbout.SetAll("value",0,"checkbox")
		oCheckBox.value=1
		ThisForm.pgfOptions.pagAbout.edtDocument.Value=FILETOSTR(oCheckBox.comment)
			
	ENDPROC

	PROCEDURE zreadme
		#IF .f.
		
		Class:  FXU.VCX/frmOptions
		
		#ENDIF
	ENDPROC

	PROCEDURE cmdCancel.Click
		THISFORM.Release()
	ENDPROC

	PROCEDURE cmdOK.Click
		THISFORM.OKAction()
		THISFORM.Release()
	ENDPROC

	PROCEDURE pgfOptions.pagAbout.Check1.Click
		ThisForm.showDocument(This)
	ENDPROC

	PROCEDURE pgfOptions.pagAbout.Check2.Click
		ThisForm.showDocument(This)
	ENDPROC

	PROCEDURE pgfOptions.pagAbout.Check3.Click
		ThisForm.showDocument(This)
	ENDPROC

	PROCEDURE pgfOptions.pagAbout.Check4.Click
		ThisForm.showDocument(This)
		
	ENDPROC

	PROCEDURE pgfOptions.pagDebugging.chkAllowDebug.Init
		THIS.Value = THISFORM.ioMainForm.ilAllowDebug
	ENDPROC

	PROCEDURE pgfOptions.pagDebugging.chkCloseDebuggerAfterTestsRun.Init
		THIS.Value = THISFORM.ioMainForm.ilCloseDebuggerAtEndOfTestsRun
	ENDPROC

	PROCEDURE pgfOptions.pagInterface.chkHonorTestPrefix.Init
		THIS.Value = THISFORM.ioMainForm.ilHonorTestPrefix
	ENDPROC

	PROCEDURE pgfOptions.pagInterface.chkReloadAll.Init
		THIS.Value = THISFORM.ioMainForm.ilReloadTestsOnRun
	ENDPROC

	PROCEDURE pgfOptions.pagInterface.chkResetColors.Init
		THIS.Value = THISFORM.ioMainForm.iResetResults
		
	ENDPROC

	PROCEDURE pgfOptions.pagInterface.chkShowTips.Init
		THIS.Value = THISFORM.ioMainForm.ShowTips
	ENDPROC

	PROCEDURE pgfOptions.pagInterface.shpFail.Click
		This.FillColor = GETCOLOR(This.FillColor)
	ENDPROC

	PROCEDURE pgfOptions.pagInterface.shpFail.Init
		
		
	ENDPROC

	PROCEDURE pgfOptions.pagInterface.shpPass.Click
		This.FillColor = GETCOLOR(This.FillColor)
	ENDPROC

	PROCEDURE pgfOptions.pagTools.cmdSelectFile.Click
		*========================================================================================
		* Let the user select a file comparison tool
		*========================================================================================
		
			*--------------------------------------------------------------------------------------
			* GetFile operates on the current folder by default. We switch to the tool folder.
			*--------------------------------------------------------------------------------------
			Local lcCurDir, lcToolDir
			lcCurDir = Sys(5) + Curdir()
			lcToolDir = JustPath(This.Parent.txtCompareTool.Value)
			If not Empty(m.lcToolDir) and Directory(m.lcToolDir, 1)
				Cd (m.lcToolDir)
			EndIf
			
			*--------------------------------------------------------------------------------------
			* User can select a new tool.
			*--------------------------------------------------------------------------------------
			Local lcTool
			lcTool = Lower(GetFile("EXE", "Select file comparison tool"))
			If not Empty(m.lcTool)
				This.Parent.txtCompareTool.Value = m.lcTool
			EndIf
			
			*--------------------------------------------------------------------------------------
			* Switch back to the previous current directory
			*--------------------------------------------------------------------------------------
			If not lcCurDir == Sys(5) + Curdir()
				Cd (m.lcCurDir)
			EndIf
			
	ENDPROC

	PROCEDURE pgfOptions.pagTools.txtCompareParameters.Init
		this.Value = thisform.ioMainForm.icCompareParameters
		
	ENDPROC

	PROCEDURE pgfOptions.pagTools.txtCompareTool.Init
		This.Value = thisform.ioMainForm.icCompareTool
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fxufrmbase AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	Caption = "Form"
	DoCreate = .T.
	Icon = ..\graphics\foxunit.ico
	Name = "fxufrmbase"

ENDDEFINE

DEFINE CLASS fxufrmloadclass AS fxufrmbase OF "fxu.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lstFiles" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdLoad" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkTestCasesOnly" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkNewTestCases" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdBrowse" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDeselectAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSelectAll" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: cancelaction
		*m: gettestcases
		*m: okaction
		*m: selectall
		*m: selectalternatetestfolder
		*m: settestcasesonlystate
		*p: icfxudefaulttestdirectory
		*p: icfxuselectedtestdirectory
		*p: ilcancel
		*a: iafiles[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED icfxudefaulttestdirectory
	AutoCenter = .T.
	Caption = "Load Class"
	Closable = .F.
	ControlBox = .F.
	DoCreate = .T.
	Height = 397
	icfxudefaulttestdirectory = .F.
	icfxuselectedtestdirectory = 
	ilcancel = .F.
	MaxButton = .F.
	MinButton = .F.
	Name = "fxufrmloadclass"
	Width = 760
	WindowType = 1
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'chkNewTestCases' AS checkbox WITH ;
		Alignment = 0, ;
		Caption = "New Test Cases", ;
		Height = 17, ;
		Left = 8, ;
		Name = "chkNewTestCases", ;
		ToolTipText = "Only list test cases that are not already in FoxUnit.", ;
		Top = 375, ;
		Value = .T., ;
		Width = 116
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkTestCasesOnly' AS checkbox WITH ;
		Alignment = 0, ;
		Caption = "Test Cases Only", ;
		Height = 17, ;
		Left = 8, ;
		Name = "chkTestCasesOnly", ;
		ToolTipText = "Only list programs that are a test case class.", ;
		Top = 354, ;
		Value = .T., ;
		Width = 112
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmdBrowse' AS commandbutton WITH ;
		Caption = "\<Browse", ;
		Default = .F., ;
		Height = 48, ;
		Left = 665, ;
		Name = "cmdBrowse", ;
		Picture = ..\graphics\fxubrowseforfolder.bmp, ;
		Top = 171, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		Cancel = .T., ;
		Caption = "\<Cancel", ;
		Height = 48, ;
		Left = 665, ;
		Name = "cmdCancel", ;
		Picture = ('fxucancel.bmp'), ;
		Top = 297, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdDeselectAll' AS commandbutton WITH ;
		Caption = "\<Deselect All", ;
		Default = .F., ;
		Height = 48, ;
		Left = 666, ;
		Name = "cmdDeselectAll", ;
		Picture = ..\graphics\fxuselectnone.bmp, ;
		Top = 108, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdLoad' AS commandbutton WITH ;
		Caption = "\<Load", ;
		Default = .F., ;
		Height = 48, ;
		Left = 665, ;
		Name = "cmdLoad", ;
		Picture = ..\graphics\fxuclassload.bmp, ;
		Top = 236, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSelectAll' AS commandbutton WITH ;
		Caption = "\<Select All", ;
		Default = .T., ;
		Height = 48, ;
		Left = 668, ;
		Name = "cmdSelectAll", ;
		Picture = ..\graphics\fxuselectall.bmp, ;
		Top = 48, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'lstFiles' AS listbox WITH ;
		Height = 333, ;
		Left = 8, ;
		MultiSelect = .T., ;
		Name = "lstFiles", ;
		RowSource = "thisform.iaFiles", ;
		RowSourceType = 5, ;
		Top = 12, ;
		Width = 648
		*< END OBJECT: BaseClass="listbox" />
	
	PROCEDURE cancelaction
		thisform.ilCancel = .T.
		thisform.Hide()
		
		
	ENDPROC

	PROCEDURE gettestcases
		LOCAL llFXUinSetProcedure, lnPrgCount
		
		LOCAL ARRAY laTestCases[1]
		LOCAL ARRAY laOldTestCases[1]
		
		llFXUinSetProcedure = 'FXU.PRG' $ SET("Procedure")
		
		IF NOT llFXUinSetProcedure
		  SET PROCEDURE TO FXU.PRG ADDITIVE 
		ENDIF 
		
		ThisForm.SetTestCasesOnlyState() 
		
		* fxuresults is the GOD cursor. HAS
		SELECT distinct tclass FROM fxuresults INTO ARRAY laOldTestCases
		
		WITH thisform 
		  DO CASE 
		    CASE .chkNewTestCases.value AND .chkTestCasesOnly.value
		      *
		      * List only New Test Cases
		      *
		      lnPrgCount = getArrayOfNewTestCases(@laTestCases, @laOldTestCases, ThisForm.icFxuSelectedTestDirectory)
		    CASE .ChkTestCasesOnly.value
		      *
		      * List only Test Cases
		      *
		      lnPrgCount = getArrayOfTestCases(@laTestCases, ThisForm.icFxuSelectedTestDirectory)
		    CASE .chkNewTestCases.value
		      *
		      * List only New Programs
		      *
		      lnPrgCount = getArrayOfNewProgramFiles(@laTestCases, @laOldTestCases, ThisForm.icFxuSelectedTestDirectory)    
		    OTHERWISE 
		      *
		      * List All Programs
		      *
		      lnPrgCount = getArrayOfProgramFiles(@laTestCases,ThisForm.icFxuSelectedTestDirectory)
		  ENDCASE 
		
		  DIMENSION .iafiles[1]
		 
		  *BUG If there is only one test class prg in the directory,
		  * this line would cause FoxUnit to ignore it. HAS
		  *IF ALEN(laTestCases,1) > 1 AND ;
		      TYPE('laTestCases[1,1]') = 'C'
		  IF ALEN(laTestCases,1) > 0 AND ;
		      TYPE('laTestCases[1,1]') = 'C'
		
		    ACOPY(laTestCases, .iaFiles)
		 
		    .cmdLoad.Enabled = .T.  
		
		  ELSE 
		 
		    .iaFiles[1] = "No Test Cases Found"
		    .cmdLoad.Enabled = .F.  
		 
		  ENDIF   
		
		ENDWITH
		
		thisform.lstFiles.Requery()
		
		RELEASE laOldTestCases
		
		RELEASE laTestCases
		
		IF NOT llFXUinSetProcedure
		
		  TRY 
		    RELEASE PROCEDURE FXU
		  CATCH TO oException
		  ENDTRY
		  
		ENDIF 
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS tcDataPath
		
		Thisform.MinHeight	= thisform.Height	&& FDBOZZO
		thisform.MinWidth	= thisform.Width	&& FDBOZZO
		
		*FIXME I still don't understand why we always look here.   Doesn't anybody else
		* store their tests with the project in version control? 
		* Why not use the current value of SET DEFAULT, at least? HAS
		thisform.icFxuDefaultTestDirectory = EVL( tcDataPath, ADDBS(JUSTPATH(FULLPATH("FXUResults.DBF"))) )
		
		thisform.icFxuSelectedTestDirectory = thisform.icFxuDefaultTestDirectory
		
		thisform.getTestCases()
		
	ENDPROC

	PROCEDURE okaction
		thisform.ilCancel = .F.
		thisform.Hide()
		
	ENDPROC

	PROCEDURE selectall
		LPARAMETERS tlSelect
		
		LOCAL lnX
		
		IF EMPTY(tlSelect)
			tlSelect = .f.
		ELSE
			tlSelect = .t.
		ENDIF
		
		FOR lnX = 1 TO ThisForm.lstFiles.ListCount
		
			ThisForm.lstFiles.Selected(lnX) = tlSelect
		
		ENDFOR
	ENDPROC

	PROCEDURE selectalternatetestfolder
		LOCAL lcSelectedTestDirectory
		
		lcSelectedTestDirectory = GETDIR(this.icFxuDefaultTestDirectory, "Select Test Folder", "Select Test Folder", 1+2+8+16+32+64) && Added nFlags parameter. HAS
		
		IF DIRECTORY(lcSelectedTestDirectory)
			
			ThisForm.icFxuSelectedTestDirectory = lcSelectedTestDirectory
		
			this.GetTestCases()
		
		ENDIF 
	ENDPROC

	PROCEDURE settestcasesonlystate
		IF !UPPER( ThisForm.icFxuSelectedTestDirectory ) == UPPER( this.icFxuDefaultTestDirectory )
		
			ThisForm.chkTestCasesOnly.Value = .t.
			ThisForm.chkTestCasesOnly.Enabled = .f.
			
		ELSE
		
			ThisForm.chkTestCasesOnly.Enabled = .t.
			
		ENDIF 
		
		ThisForm.chkTestCasesOnly.Refresh()
	ENDPROC

	PROCEDURE chkNewTestCases.Click
		thisform.getTestCases()
	ENDPROC

	PROCEDURE chkTestCasesOnly.Click
		thisform.getTestCases()
	ENDPROC

	PROCEDURE cmdBrowse.Click
		ThisForm.SelectAlternateTestFolder()
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		thisform.cancelaction()
	ENDPROC

	PROCEDURE cmdDeselectAll.Click
		ThisForm.SelectAll(.f.)
	ENDPROC

	PROCEDURE cmdLoad.Click
		thisform.okAction()
		
	ENDPROC

	PROCEDURE cmdSelectAll.Click
		thisform.SelectAll(.t.)
	ENDPROC

	PROCEDURE lstFiles.DblClick
		thisform.OkAction()
	ENDPROC

ENDDEFINE

DEFINE CLASS fxufrmnewtestclass AS fxufrmuser OF "fxu.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="opgTemplateSource" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblValidationMsg" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTestFolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPickTestFolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCreate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lstTemplates" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCurrentTestFolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtTestClassName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtExistingFile" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkProcedure" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkTab" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSelectCustomTemplate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSelectFile" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTemplate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblOptions" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRemoveTemplate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdEditTemplate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCopyExisting" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblSaveAs" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addcustomtemplates
		*m: addtemplate
		*m: addvmptemplates
		*m: chooseexistingclass
		*m: classfullname
		*m: createtestclass
		*m: createtestforclasslib		&& Create mockunit tests for every class in a classlib
		*m: createtestsforclasslib
		*m: getyourfxutemplate		&& Select template file to copy
		*m: icclassvalidationmessage_assign
		*m: modifytemplate
		*m: picktestfolder
		*m: removemissingtemplates
		*m: removetemplate
		*m: selectfile		&& Get filename of test class to copy or classlib to mock
		*m: showcontrols
		*m: sortoptionaltemplates
		*m: templateclassinheritsfromfxutestcase
		*m: txtclassname
		*m: validatederivedtestcasetemplate
		*m: validatetestclass
		*m: validtemplatefile
		*m: zreadme
		*p: cclassname
		*p: cerror
		*p: cexistingfile
		*p: ctestfolder
		*p: icclassvalidationmessage
		*p: iclasterrormessage		&& Error messages
		*p: icnewtestclass
		*p: icresultvariable
		*p: inpermanenttemplates
		*p: iuretval
		*p: lcreated		&& Was a new test class created?
		*p: luseprocedure		&& Use the word PROCEDURE instead of METHOD
		*p: lusetabs		&& Use TABS rather than spaces
		*p: lvalidclassname
		*p: ntemplatesource
		*a: iatemplates[1,0]
	*</DefinedPropArrayMethod>

	AllowOutput = .F.
	AutoCenter = .T.
	BorderStyle = 1
	Caption = "New Test Class"
	cclassname = ("")
	cerror = .F.
	cexistingfile = ("")
	ctestfolder = ("")
	DoCreate = .T.
	FontName = "Verdana"
	FontSize = 10
	Height = 431
	icclassvalidationmessage = ("")
	iclasterrormessage = ("")		&& Error messages
	inpermanenttemplates = 0
	iofxuinstance = .NULL.
	iuretval = .NULL.
	lcreated = .F.		&& Was a new test class created?
	luseprocedure = .F.		&& Use the word PROCEDURE instead of METHOD
	lusetabs = .T.		&& Use TABS rather than spaces
	lvalidclassname = .F.
	MaxButton = .F.
	MinButton = .F.
	Name = "fxufrmnewtestclass"
	ntemplatesource = 1
	ShowInTaskBar = .F.
	ShowTips = .T.
	ShowWindow = 1
	Width = 804
	WindowType = 1
	_memberdata = <VFPData>
		<memberdata name="validatetestclass" display="ValidateTestClass"/>
		<memberdata name="picktestfolder" display="pickTestFolder"/>
		<memberdata name="showcontrols" display="showControls"/>
		<memberdata name="createtestsforclasslib" display="createTestsForClasslib"/>
		</VFPData>

	ADD OBJECT 'chkProcedure' AS checkbox WITH ;
		Alignment = 6, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = 'Use "PROCEDURE MethodName" rather than "FUNCTION MethodName" ', ;
		ControlSource = "w", ;
		Enabled = .F., ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		Height = 16, ;
		Left = 22, ;
		Name = "chkProcedure", ;
		TabIndex = 17, ;
		Top = 235, ;
		Value = .F., ;
		Width = 471, ;
		WordWrap = .F., ;
		ZOrderSet = 10
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkTab' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Indent methods by one TAB", ;
		ControlSource = "ThisForm.lUseTabs", ;
		Enabled = .F., ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		Height = 16, ;
		Left = 22, ;
		Name = "chkTab", ;
		TabIndex = 16, ;
		Top = 219, ;
		Value = .T., ;
		Width = 194, ;
		ZOrderSet = 11
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmdAdd' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "+", ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		Height = 27, ;
		Left = 764, ;
		Name = "cmdAdd", ;
		Picture = ..\graphics\list2_add.png, ;
		PicturePosition = 14, ;
		TabIndex = 8, ;
		ToolTipText = "Add a template file to this list", ;
		Top = 32, ;
		Width = 27, ;
		ZOrderSet = 16
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdCreate' AS commandbutton WITH ;
		Caption = "Create Test Class", ;
		Default = .F., ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		Height = 40, ;
		Left = 648, ;
		Name = "cmdCreate", ;
		TabIndex = 4, ;
		Top = 384, ;
		Width = 144, ;
		WordWrap = .T., ;
		ZOrderSet = 5
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdEditTemplate' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "M", ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		Height = 27, ;
		Left = 764, ;
		Name = "cmdEditTemplate", ;
		Picture = ..\graphics\list_information.png, ;
		PicturePosition = 14, ;
		TabIndex = 10, ;
		ToolTipText = "Modify the Selected Template", ;
		Top = 86, ;
		Width = 27, ;
		ZOrderSet = 18
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdPickTestFolder' AS commandbutton WITH ;
		Caption = "...", ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		Height = 25, ;
		Left = 768, ;
		Name = "cmdPickTestFolder", ;
		TabIndex = 21, ;
		Top = 284, ;
		Width = 24, ;
		ZOrderSet = 3
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdRemoveTemplate' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "-", ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		Height = 27, ;
		Left = 764, ;
		Name = "cmdRemoveTemplate", ;
		Picture = ..\graphics\list1_delete.png, ;
		PicturePosition = 14, ;
		TabIndex = 9, ;
		ToolTipText = "Remove the selected template file from this list", ;
		Top = 59, ;
		Width = 27, ;
		ZOrderSet = 17
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSelectCustomTemplate' AS commandbutton WITH ;
		Caption = "C", ;
		Default = .F., ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		Height = 28, ;
		Left = 764, ;
		Name = "cmdSelectCustomTemplate", ;
		Picture = ..\graphics\list_go.png, ;
		PicturePosition = 14, ;
		TabIndex = 11, ;
		ToolTipText = "Select a custom FoxUnit template of your own.  If you select one that is not in the list above, it will be automatically added to the list the next time you invoke this dialog.", ;
		Top = 113, ;
		Width = 27, ;
		WordWrap = .T., ;
		ZOrderSet = 12
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSelectFile' AS commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "Select...", ;
		Default = .T., ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		Height = 25, ;
		Left = 225, ;
		Name = "cmdSelectFile", ;
		TabIndex = 13, ;
		Top = 151, ;
		Visible = .F., ;
		Width = 64, ;
		WordWrap = .T., ;
		ZOrderSet = 13
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'Label2' AS label WITH ;
		AutoSize = .T., ;
		Caption = "Test Class/File Name:", ;
		FontBold = .F., ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		Height = 16, ;
		Left = 22, ;
		Name = "Label2", ;
		TabIndex = 1, ;
		Top = 315, ;
		Width = 138, ;
		ZOrderSet = 4
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblCopyExisting' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "", ;
		FontBold = .F., ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		Height = 16, ;
		Left = 36, ;
		Name = "lblCopyExisting", ;
		TabIndex = 12, ;
		Top = 155, ;
		Width = 2, ;
		ZOrderSet = 19
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblOptions' AS label WITH ;
		AutoSize = .T., ;
		Caption = "Code Options:", ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		ForeColor = 128,0,0, ;
		Height = 16, ;
		Left = 12, ;
		Name = "lblOptions", ;
		TabIndex = 15, ;
		Top = 203, ;
		Width = 93, ;
		ZOrderSet = 15
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblSaveAs' AS label WITH ;
		AutoSize = .T., ;
		Caption = "Save as:", ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		ForeColor = 128,0,0, ;
		Height = 16, ;
		Left = 12, ;
		Name = "lblSaveAs", ;
		TabIndex = 18, ;
		Top = 264, ;
		Width = 57, ;
		ZOrderSet = 20
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblTemplate' AS label WITH ;
		Anchor = 3, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Template", ;
		FontBold = .F., ;
		FontName = "Tahoma", ;
		FontSize = 12, ;
		ForeColor = 128,0,0, ;
		Height = 21, ;
		Left = 12, ;
		Name = "lblTemplate", ;
		TabIndex = 5, ;
		Top = 10, ;
		Width = 68, ;
		ZOrderSet = 14
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblTestFolder' AS label WITH ;
		AutoSize = .T., ;
		Caption = "Test Folder:", ;
		FontBold = .F., ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		Height = 16, ;
		Left = 22, ;
		Name = "lblTestFolder", ;
		TabIndex = 19, ;
		Top = 283, ;
		Width = 77, ;
		ZOrderSet = 2
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblValidationMsg' AS label WITH ;
		Caption = "", ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		ForeColor = 255,0,0, ;
		Height = 25, ;
		Left = 12, ;
		Name = "lblValidationMsg", ;
		TabIndex = 3, ;
		Top = 341, ;
		Width = 625, ;
		ZOrderSet = 1
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lstTemplates' AS listbox WITH ;
		ColumnCount = 2, ;
		ColumnLines = .F., ;
		ColumnWidths = "304,336", ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		Height = 116, ;
		IntegralHeight = .T., ;
		ItemTips = .T., ;
		Left = 36, ;
		Name = "lstTemplates", ;
		TabIndex = 7, ;
		Top = 33, ;
		Width = 724, ;
		ZOrderSet = 6
		*< END OBJECT: BaseClass="listbox" />

	ADD OBJECT 'opgTemplateSource' AS optiongroup WITH ;
		Anchor = 3, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		ButtonCount = 3, ;
		ControlSource = "ThisForm.nTemplateSource", ;
		Height = 168, ;
		Left = 13, ;
		Name = "opgTemplateSource", ;
		TabIndex = 6, ;
		Top = 33, ;
		Value = 1, ;
		Width = 246, ;
		ZOrderSet = 0, ;
		Option1.Caption = "", ;
		Option1.Height = 17, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.Top = 5, ;
		Option1.Value = 1, ;
		Option1.Width = 61, ;
		Option2.AutoSize = .T., ;
		Option2.Caption = "\<Copy an existing Test Class", ;
		Option2.Height = 17, ;
		Option2.Left = 5, ;
		Option2.Name = "Option2", ;
		Option2.ToolTipText = "This option copies an existing test class PRG to a new test class PRG.", ;
		Option2.Top = 124, ;
		Option2.Width = 171, ;
		Option3.AutoSize = .T., ;
		Option3.Caption = "Create \<Stub tests from an existing class", ;
		Option3.Height = 17, ;
		Option3.Left = 5, ;
		Option3.Name = "Option3", ;
		Option3.ToolTipText = "This option will create stub tests for every method in a class library.", ;
		Option3.Top = 146, ;
		Option3.Width = 236
		*< END OBJECT: BaseClass="optiongroup" />

	ADD OBJECT 'txtCurrentTestFolder' AS textbox WITH ;
		ControlSource = "ThisForm.cTestFolder", ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		Height = 25, ;
		Left = 161, ;
		Name = "txtCurrentTestFolder", ;
		ReadOnly = .T., ;
		TabIndex = 20, ;
		Top = 284, ;
		Width = 605, ;
		ZOrderSet = 7
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'txtExistingFile' AS textbox WITH ;
		ControlSource = "ThisForm.cExistingFile", ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		Height = 25, ;
		Left = 290, ;
		Name = "txtExistingFile", ;
		TabIndex = 14, ;
		TabStop = .F., ;
		Top = 151, ;
		Visible = .F., ;
		Width = 470, ;
		ZOrderSet = 9
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'txtTestClassName' AS textbox WITH ;
		ControlSource = "ThisForm.cClassName", ;
		FontName = "Verdana", ;
		FontSize = 9, ;
		Height = 25, ;
		Left = 161, ;
		MaxLength = 110, ;
		Name = "txtTestClassName", ;
		TabIndex = 2, ;
		Top = 314, ;
		Width = 629, ;
		ZOrderSet = 8
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE addcustomtemplates
	ENDPROC

	PROCEDURE addtemplate
		*
		*  called from THIS.lstTemplates.RightClick() 
		*  and from THIS.GetYourFXUTemplate()
		*
		LPARAMETERS tcFileName
		
		LOCAL lcFileName, xx, lcDescription, lnRow, yy, llAlready
		
		IF PCOUNT() = 0
		  lcFileName = GETFILE("TXT","FoxUnit template","Select",0,"Select a FoxUnit test class .TXT template")
		 ELSE
		  lcFileName = m.tcFileName
		ENDIF
		IF EMPTY(m.lcFileName)
		  RETURN
		ENDIF
		
		lcFileName = UPPER(ALLTRIM(m.lcFileName))
		
		FOR xx = 1 TO ALEN(THIS.iaTemplates,1)
		  IF UPPER(ALLTRIM(THIS.iaTemplates[m.xx,3])) == m.lcFileName
		    llAlready = .t.
		    EXIT
		  ENDIF
		ENDFOR
		IF m.llAlready
		  MESSAGEBOX(m.lcFileName + " is already in the list!", ;
		             16, ;
		             "Please Note")
		  RETURN
		ENDIF
		
		IF NOT THIS.ValidTemplateFile(m.lcFileName)
		  MESSAGEBOX(JUSTFNAME(m.lcFileName) + ;
		             " is not a FoxUnit test case class inheriting from FXUTestCase.PRG", ;
		             48, ;
		             "Please Note")
		  RETURN
		ENDIF
		
		IF PCOUNT() = 0
		  lcDescription = INPUTBOX("Description", ;
		                           "Enter a short description")
		ENDIF
		IF EMPTY(m.lcDescription)
		  lcDescription = "Custom FoxUnit template"
		ENDIF
		
		*
		*  add it
		*
		lnRow = ALEN(THIS.iaTemplates,1)+1
		DIMENSION THIS.iaTemplates[m.lnRow,ALEN(THIS.iaTemplates,2)]
		THIS.iaTemplates[m.lnRow,1] = m.lcDescription
		THIS.iaTemplates[m.lnRow,2] = JUSTFNAME(m.lcFileName)
		THIS.iaTemplates[m.lnRow,3] = m.lcFileName
		
		THIS.SortOptionalTemplates()
		
		THIS.lstTemplates.Value = m.lnRow
		THIS.lstTemplates.RowSource = THIS.lstTemplates.RowSource
		
		                         
		                         
		
		
	ENDPROC

	PROCEDURE addvmptemplates
		*
		*  FXU.VCX/frmGetTestClassTemplate::AddVMPTemplates()  
		*
		*
		*  add VMP-specific (Visual MaxFrame Professional) templates
		*
		IF NOT FILE("XXFW.VCX")
			RETURN
		ENDIF
		
		LOCAL lnRow, lnCols, lcCurDir, lcXLIB, laFiles[1], lnFiles, xx, ;
			lcFileName, lcDesc, lcDescText, laLines[1]
		m.lnRow = ALEN(THIS.iaTemplates, 1)
		m.lnCols = ALEN(THIS.iaTemplates, 2)
		m.lcCurDir = FULLPATH(CURDIR())
		m.lcXLIB = JUSTPATH(FULLPATH("XXFW.VCX"))
		
		CD (m.lcXLIB)
		
		m.lnFiles = ADIR(laFiles, "VMPFXU*.TXT")
		
		CD (m.lcCurDir)
		
		IF m.lnFiles = 0
			RETURN
		ENDIF
		
		FOR m.xx = 1 TO m.lnFiles
			m.lcFileName = UPPER(m.laFiles[m.xx, 1])
			IF NOT "TEMPLATE" $ m.lcFileName
				LOOP
			ENDIF
			IF ASCAN(THIS.iaTemplates, m.lcFileName, -1, -1, 2, 15) > 0
		*  already in the list
				LOOP
			ENDIF
			m.lnRow = m.lnRow + 1
			DIMENSION THIS.iaTemplates[m.lnRow, m.lnCols]
			ALINES(laLines, FILETOSTR(m.lcFileName))
			m.lcDescText = m.laLines[2]   &&& description is on the 2nd line of the .TXT template file
			m.lcDescText = ALLTRIM(SUBSTRC(m.lcDescText, 2))   &&& remove leading asterisk
		
		*!*	  DO CASE
		*!*	    CASE RIGHTC(m.lcFileName,7) = "_DS.TXT"
		*!*	      lcDescText = "VMP DataSource test case template"
		*!*	    CASE RIGHTC(m.lcFileName,7) = "_BO.TXT"
		*!*	      lcDescText = "VMP Business Object test case template"
		*!*	    CASE RIGHTC(m.lcFileName,16) = "_BO_ONE2MANY.TXT"
		*!*	      lcDescText = "VMP One2Many Business Object test case template"
		*!*	    CASE RIGHTC(m.lcFileName,21) = "_BO_ONE2MANY2MANY.TXT"
		*!*	      lcDescText = "VMP One2Many2Many Business Object test case template"
		*!*	    OTHERWISE
		*!*	      lcDescText = "VMP test case template"
		*!*	  ENDCASE
		
			THIS.iaTemplates[m.lnRow, 1] = m.lcDescText
			THIS.iaTemplates[m.lnRow, 2] = m.laFiles[m.xx, 1]
			THIS.iaTemplates[m.lnRow, 3] = FULLPATH(m.lcFileName)
			THIS.iaTemplates[m.lnRow, 4] = .T.   &&& permanent
		NEXT
		
		THIS.lstTemplates.ROWSOURCE = THIS.lstTemplates.ROWSOURCE
		
		
	ENDPROC

	PROCEDURE chooseexistingclass
		LOCAL lReturn
		lReturn = ThisForm.selectFile()
		IF lReturn
			ThisForm.cClassName = JUSTSTEM(PROPER(Thisform.cExistingfile))+"_Tests"
			ThisForm.txtTestClassName.setFocus()
			ThisForm.cTestFolder = ADDBS(JUSTPATH(ThisForm.cExistingfile))+"Tests"
			IF NOT DIRECTORY(ThisForm.cTestFolder)
				TRY
					MD (ThisForm.cTestFolder)
				CATCH TO oEx
					ThisForm.cError = oEx.message
				ENDTRY
			ENDIF 	
		ELSE
			ThisForm.cClassName = ""
		ENDIF
		This.opgTemplateSource.option3.Caption="Create \<Stub tests from " + IIF(lReturn, Thisform.cExistingfile, "an existing class")
		ThisForm.nTemplatesource=3
		
		RETURN lReturn
		
	ENDPROC

	PROCEDURE classfullname
		RETURN FORCEEXT(ADDBS(ALLTRIM(This.cTestFolder)) + ALLTRIM(This.cClassName),"prg")
		
	ENDPROC

	PROCEDURE createtestclass
		LOCAL lcTemplateFile, lcNewTestClassName
		LOCAL loTestClassCreator AS FxuNewTestClass OF FxuNewTestClass.prg
		LOCAL loTestClassCreator 
		
		This.lCreated =.f.
		loTestClassCreator = thisform.ioFxuInstance.FxuNewObject("FxuNewTestClass")
		lcNewTestClassName= This.ClassFullName() 
		
		*SET PATH TO (["] + JUSTPATH(m.lcNewTestClassName) + ["]) ADDITIVE && Add new location to path. HAS
		
		IF NOT EMPTY(This.cClassName)	 && This shouldn't ever happen, as the button won't be enabled via showControls() unless there's a value there
		
		IF This.nTemplatesource=1 OR This.nTemplatesource = 3	&& Template or Stubs
			* Verify template exists
			IF FILE(THISFORM.iaTemplates[THISFORM.lstTemplates.Value, 3])
				m.lcTemplateFile = THISFORM.iaTemplates[THISFORM.lstTemplates.Value, 3]
			ELSE
				IF MESSAGEBOX("Unable to locate " + ;
						  CHR(13) + ;
						  THISFORM.iaTemplates[THISFORM.lstTemplates.Value, 3] + ;
						  CHR(13) + CHR(13) + ;
						  "Remove it from the list?", ;
						  16 + 4, ;
						  "Please Note") = 6
					THISFORM.RemoveTemplate()
				ENDIF
			ENDIF
			This.lCreated = loTestClassCreator.CreateNewTestClass(m.lcNewTestClassName, m.lcTemplateFile, This.lUseTabs, This.lUseProcedure)
		
			IF This.lCreated AND This.nTemplatesource=3	&& Create mock tests for an existing classlib
				This.createTestsForClasslib()
			ENDIF
		ELSE	&& Copy existing class
			IF loTestClassCreator.LoadExistingClassProgram(This.cExistingFile)
				loTestClassCreator.MergeClassName(JUSTSTEM(lcNewTestClassName))
				STRTOFILE(loTestClassCreator.icTemplateContents, lcNewTestClassName)
				This.lCreated = FILE(lcNewTestClassName)
			ENDIF	
		ENDIF 
		ENDIF
		
		
		
	ENDPROC

	PROCEDURE createtestforclasslib		&& Create mockunit tests for every class in a classlib
	ENDPROC

	PROCEDURE createtestsforclasslib
		LOCAL cClassLib
		cClassLib = This.cExistingFile
		
		IF NOT EMPTY(cClassLib)
			goFoxUnitForm.ioResultData.AddTestsFromClassLib(This.classFullName(), ThisForm, JUSTPATH(This.cExistingFile), cClassLib)
		ENDIF
		
	ENDPROC

	PROCEDURE Destroy
		THIS.SettingsSave(".\FXUPersistGetTemplate.XML")
		
	ENDPROC

	PROCEDURE getyourfxutemplate		&& Select template file to copy
		*  
		*  called from THIS.cmdSelectCustomTemplate.Click()
		*
		
		
		LOCAL lcFileName, xx, llAlready
		
		lcFileName = GETFILE("TXT","FoxUnit template","Select",0,"Select a FoxUnit test class .TXT template")
		
		IF EMPTY(m.lcFileName)
		  RETURN
		ENDIF
		
		IF NOT THIS.ValidTemplateFile(m.lcFileName)
		  IF MESSAGEBOX(JUSTFNAME(m.lcFileName) + ;
		             " is not a FoxUnit test case class inheriting from FXUTestCase.PRG." + ;
		             CHR(10) + "Do you wish to load this test case template anyway?", ;
		             4+48,  ;
		             "Please Note") = 7
		  	RETURN
		  ENDIF
		ENDIF
		
		*
		*  if the selected template isn't already in the list,
		*  put it in the list so it's there from now on
		*
		FOR xx = 1 TO ALEN(THIS.iaTemplates,1)
		  IF UPPER(ALLTRIM(THIS.iaTemplates[m.xx,3])) == m.lcFileName
		    llAlready = .t.
		    EXIT
		  ENDIF
		ENDFOR
		
		IF m.llAlready
		  RETURN m.lcFileName
		ENDIF  
		
		THIS.AddTemplate(m.lcFileName)
		
		RETURN m.lcFileName
		          
	ENDPROC

	PROCEDURE icclassvalidationmessage_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		
		this.cmdCreate.Enabled = EMPTY(vNewVal)
		
		this.lblValidationMsg.Caption = vNewVal
		thisform.cmdCreate.Refresh()
		thisform.lblValidationMsg.Refresh()
		THIS.icclassvalidationmessage = m.vNewVal
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toFxuInstance, tcNewTestClass, tcResultVariable
		
		IF !DODEFAULT(@m.toFxuInstance)
			RETURN .F.
		ENDIF
		
		This.cTestFolder=m.toFxuInstance.DataPath
		THIS.icNewTestClass = EVL(m.tcNewTestClass,"")
		THIS.icResultVariable = m.tcResultVariable
		This.Icon="foxunit.ico"
		
		THIS.MinHeight = THIS.Height
		THIS.MinWidth = THIS.Width
		
		IF VERSION(5) < 900
		  THIS.BorderStyle = 2
		ENDIF
		
		*
		*  Save these for use in THIS.OnSettingsSave()
		*
		THIS.AddProperty("inDesignHeight",THIS.Height)
		THIS.AddProperty("inDesignWidth",THIS.Width)
		
		THIS.SettingsRestore(".\FXUPersistGetTemplate.XML")
		THIS.RemoveMissingTemplates()
		THIS.AddVMPTemplates()
		*
		*  if you subclass this form, you can add code here
		*  to add your own custom templates
		*
		THIS.AddCustomTemplates()
		This.ValidateTestClass()
		
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		If nKeyCode=27
		   Thisform.Hide()
		Endif 
		
	ENDPROC

	PROCEDURE modifytemplate
		*
		*  called from THIS.lstTemplates.RightClick()
		*
		
		LOCAL lcFileName
		m.lcFileName = THIS.iaTemplates[THIS.lstTemplates.Value, 3]
		IF EMPTY(m.lcFileName)
			MESSAGEBOX("This feature is only available for those " + ;
				  "items for which a filename has been specified.", ;
				  48, ;
				  "Please Note")
			RETURN
		ENDIF
		
		MODIFY COMMAND (m.lcFileName)
		
	ENDPROC

	PROCEDURE onsettingssave
		PARAMETERS tcAlias
		
		IF VARTYPE(m.tcAlias)!="C" OR !USED(m.tcAlias)
			RETURN .F.
		ENDIF
		
		SELECT (m.tcAlias)
		SCATTER MEMVAR
		m.UserID = THIS.ioFxuInstance.UserId
		
		*
		*  THISFORM settings
		*
		m.Setting = "THIS.Top = " + TRANSFORM(THIS.TOP)
		INSERT INTO (m.tcAlias) FROM MEMVAR
		m.Setting = "THIS.Left = " + TRANSFORM(THIS.LEFT)
		INSERT INTO (m.tcAlias) FROM MEMVAR
		m.Setting = "THIS.Height = IIF(VERSION(5)>=900," + TRANSFORM(THIS.HEIGHT) + "," + TRANSFORM(THIS.inDesignHeight) + ")"
		INSERT INTO (m.tcAlias) FROM MEMVAR
		m.Setting = "THIS.Width = IIF(VERSION(5)>=900," + TRANSFORM(THIS.WIDTH) + "," + TRANSFORM(THIS.inDesignWidth) + ")"
		INSERT INTO (m.tcAlias) FROM MEMVAR
		
		*
		*  THISFORM checkbox values
		*
		m.Setting = "THIS.chkProcedure.Value = " + TRANSFORM(THIS.chkProcedure.VALUE)
		INSERT INTO (m.tcAlias) FROM MEMVAR
		m.Setting = "THIS.chkTab.Value = " + TRANSFORM(THIS.chkTab.VALUE)
		INSERT INTO (m.tcAlias) FROM MEMVAR
		
		*
		*  THIS.lstTemplates.Value
		*
		m.Setting = "THIS.lstTemplates.Value = " + TRANSFORM(THIS.lstTemplates.VALUE)
		INSERT INTO (m.tcAlias) FROM MEMVAR
		
		*
		*  all templates after the permanent templates
		*
		
		IF ALEN(THIS.iaTemplates, 1) > THIS.inPermanentTemplates
			m.Setting = 'DIMENSION THIS.iaTemplates[' + TRANSFORM(ALEN(THIS.iaTemplates, 1)) + ',' + TRANSFORM(ALEN(THIS.iaTemplates, 2)) + ']'
			INSERT INTO (m.tcAlias) FROM MEMVAR
			LOCAL xx, yy
			FOR m.xx = THIS.inPermanentTemplates + 1 TO ALEN(THIS.iaTemplates, 1)
				IF EMPTY(THIS.iaTemplates[m.xx, 2]) OR NOT FILE(THIS.iaTemplates[m.xx, 3])
					LOOP
				ENDIF
				FOR m.yy = 1 TO ALEN(THIS.iaTemplates, 2) - 1
					m.Setting = 'THIS.iaTemplates[' + TRANSFORM(m.xx) + ',' + TRANSFORM(m.yy) + '] = "' + TRANSFORM(THIS.iaTemplates[m.xx, m.yy]) + ["]
					INSERT INTO (m.tcAlias) FROM MEMVAR
				ENDFOR
				m.Setting = 'THIS.iaTemplates[' + TRANSFORM(m.xx) + ',' + TRANSFORM(ALEN(THIS.iaTemplates, 2)) + '] = ' + TRANSFORM(THIS.iaTemplates[m.xx, m.yy])
				INSERT INTO (m.tcAlias) FROM MEMVAR
			ENDFOR
			m.Setting = "THIS.lstTemplates.RowSource = THIS.lstTemplates.RowSource"
			INSERT INTO (m.tcAlias) FROM MEMVAR
		ENDIF
	ENDPROC

	PROCEDURE picktestfolder
		LOCAL lcChangedTestFolder
		
		m.lcChangedTestFolder = ""
		
		m.lcChangedTestFolder = GETDIR(THISFORM.txtCurrentTestFolder.VALUE, "Select test class folder", "Select test class folder", 1 + 2 + 8 + 16 + 32 + 64) && Added nFlag parameter. HAS
		
		IF DIRECTORY(m.lcChangedTestFolder)
			THISFORM.txtCurrentTestFolder.VALUE = m.lcChangedTestFolder
			THISFORM.Validatetestclass()
			IF !EMPTY(THISFORM.icClassValidationMessage)
				THISFORM.txtTestClassName.SETFOCUS()
			ELSE
				THISFORM.cmdCreate.SETFOCUS()
			ENDIF
		
		ENDIF
	ENDPROC

	PROCEDURE QueryUnload
		IF This.ReleaseType=1
			nodefault
			This.Hide()
		ENDIF
		
	ENDPROC

	PROCEDURE Release
		IF This.ReleaseType=1
			This.Hide()
		ENDIF
		
	ENDPROC

	PROCEDURE removemissingtemplates
		*
		*  remove any rows of THIS.lstTemplates that have
		*  been added by THIS.RestoreSettings(), but which
		*  templates are now missing
		*
		
		LOCAL xx, lnRows, lnRemoved, lnValue
		m.lnRows = ALEN(THIS.iaTemplates, 1)
		m.lnValue = THIS.lstTemplates.VALUE
		
		IF m.lnRows < 5
		*  nothing to do
			RETURN
		ENDIF
		
		m.lnRemoved = 0
		FOR m.xx = m.lnRows TO 5 STEP - 1
			IF NOT FILE(THIS.iaTemplates[m.xx, 3])
				m.lnRemoved = m.lnRemoved + 1
				ADEL(THIS.iaTemplates, m.xx)
			ENDIF
		ENDFOR
		IF m.lnRemoved > 0
			DIMENSION THIS.iaTemplates[m.lnRows - m.lnRemoved, ALEN(THIS.iaTemplates, 2)]
			THIS.lstTemplates.ROWSOURCE = THIS.lstTemplates.ROWSOURCE
			THIS.lstTemplates.VALUE = 1
		ENDIF
		
		
		
		
	ENDPROC

	PROCEDURE removetemplate
		*
		*  called from THIS.lstTemplates.RightClick()
		*
		
		IF THIS.iaTemplates[THIS.lstTemplates.Value, 4]
			MESSAGEBOX("This is a permanent item and may not be removed." + ;
				  CHR(13) + CHR(13) + ;
				  "You may only remove any custom templates of your own.", ;
				  48, ;
				  "Please Note")
			RETURN
		ENDIF
		
		IF MESSAGEBOX("Are you sure you want to remove " + THIS.iaTemplates[THIS.lstTemplates.Value, 2] + "?", ;
				  4 + 48, ;
				  "Please confirm") = 7
			RETURN
		ENDIF
		
		LOCAL lnRow
		m.lnRow = THIS.lstTemplates.VALUE
		ADEL(THIS.iaTemplates, m.lnRow)
		DIMENSION THIS.iaTemplates[ALEN(THIS.iaTemplates, 1) - 1, ALEN(THIS.iaTemplates, 2)]
		IF m.lnRow > ALEN(THIS.iaTemplates, 1)
			THIS.lstTemplates.VALUE = THIS.lstTemplates.VALUE - 1
		ENDIF
		THIS.lstTemplates.ROWSOURCE = THIS.lstTemplates.ROWSOURCE
		
		
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE selectfile		&& Get filename of test class to copy or classlib to mock
		*  
		*  called from THIS.cmdCopyExistingPRG.Click()
		*
		LOCAL lcFileName, llReturn
		
		IF This.nTemplatesource = 2
			m.lcFileName = GETFILE("PRG", "FoxUnit test class", "Select", 0, "Select an existing FoxUnit test class .PRG")
			IF NOT EMPTY(m.lcFileName)
				llReturn = THIS.ValidTemplateFile(m.lcFileName)
				IF NOT llReturn
					MESSAGEBOX(JUSTFNAME(m.lcFileName) + ;
						  " is not a FoxUnit test case class inheriting from FXUTestCase.PRG", ;
						  48, ;
						  "Please Note")
				ENDIF
			ENDIF
		ELSE
			m.lcFileName = GETFILE("VCX,PRG", "FoxUnit test class", "Select", 0, "Select a VFP Class Library")
			llReturn = ! EMPTY(m.lcFileName)
		ENDIF
		This.cExistingFile = IIF(llReturn, lcFileName, "")
		This.showControls()
		RETURN llReturn
		
	ENDPROC

	PROCEDURE showcontrols
		
		THISFORM.lstTemplates.ENABLED = (THIS.nTemplatesource = 1)
		THIS.cmdAdd.ENABLED = (THIS.nTemplatesource = 1)
		THIS.cmdRemoveTemplate.ENABLED = (THIS.nTemplatesource = 1)
		THIS.cmdEditTemplate.ENABLED = (THIS.nTemplatesource = 1)
		THIS.cmdselectCustomTemplate.ENABLED = (THIS.nTemplatesource = 1)
		
		THIS.cmdSelectFile.Visible = (THIS.nTemplatesource = 2)
		THIS.txtExistingFile.Visible = (THIS.nTemplatesource = 2)
		
		DO CASE 
			CASE This.nTemplatesource = 1
			* Normal Template
		
			CASE This.nTemplateSource = 2	
				This.cmdCreate.Enabled = not EMPTY(This.cExistingFile) and FILE(This.cExistingFile) ;
					AND This.lValidClassName
		
			CASE This.nTemplateSource = 3
				This.cmdCreate.Enabled = not EMPTY(This.cExistingFile) and FILE(This.cExistingFile) ;
					AND This.lValidClassName
		ENDCASE
		This.Refresh()
		
	ENDPROC

	PROCEDURE sortoptionaltemplates
		*
		*  re-sort the optional templates, in alphabetical order
		*  
		
		IF ALEN(THIS.iaTemplates, 1) = THIS.inPermanentTemplates
		*  nothing to do
			RETURN
		ENDIF
		
		LOCAL lnRows, lnCols, lnPermanentRows, xx, yy, lnRow
		m.lnRows = ALEN(THIS.iaTemplates, 1)
		m.lnCols = ALEN(THIS.iaTemplates, 2)
		m.lnPermanentRows = THIS.inPermanentTemplates
		
		LOCAL laItems[m.lnRows - THIS.inPermanentTemplates, m.lnCols]
		
		FOR m.xx = m.lnPermanentRows + 1 TO m.lnRows
			FOR m.yy = 1 TO m.lnCols
				m.laItems[m.xx - m.lnPermanentRows, m.yy] = THIS.iaTemplates[m.xx, m.yy]
			ENDFOR
		ENDFOR
		
		ASORT(m.laItems)
		
		FOR m.xx = m.lnPermanentRows + 1 TO m.lnRows
			FOR m.yy = 1 TO m.lnCols
				THIS.iaTemplates[m.xx, m.yy] = m.laItems[m.xx - m.lnPermanentRows, m.yy]
			ENDFOR
		ENDFOR
		
		*lnRow = ASCAN(THISFORM.iaTemplates,m.lcFileName,3,-1,3,15)
		
		
		
	ENDPROC

	PROCEDURE templateclassinheritsfromfxutestcase
		LPARAMETERS tcDefineClassStatement
		
		LOCAL lcTestCaseClass, lcTestCaseClassProgramFile
		
		m.tcDefineClassStatement = UPPER(ALLTRIM( m.tcDefineClassStatement ))
		
		m.tcDefineClassStatement = SUBSTR( m.tcDefineClassStatement, ;
			ATC( " AS", m.tcDefineClassStatement ) + 3)
			
		m.lcTestCaseClass = ALLTRIM(LEFT(m.tcDefineClassStatement, ;
			ATC("OF", m.tcDefineClassStatement) - 1)) 
		
		m.lcTestCaseClassProgramFile = ALLTRIM(SUBSTR(m.tcDefineClassStatement, ;
			RATC(SPACE(1), m.tcDefineClassStatement))) 	
			
		RETURN  FXUInheritsFromFxuTestCase( m.lcTestCaseClass, m.lcTestCaseClassProgramFile )  
			
		 
	ENDPROC

	PROCEDURE txtclassname
	ENDPROC

	PROCEDURE Unload
		IF NOT EMPTY(THIS.icResultVariable)
			LOCAL lcResultVariable
			m.lcResultVariable = THIS.icResultVariable
			STORE THIS.iuRetVal TO &lcResultVariable
		ENDIF
		
		RETURN THIS.iuRetVal
	ENDPROC

	PROCEDURE validatederivedtestcasetemplate
		LPARAMETERS tcTestCaseTemplate
		
		LOCAL llValidDerivedTestCaseTemplate
		LOCAL lcValidatePrg, lnLInes
		LOCAL ARRAY laLines[1]
		
		m.llValidDerivedTestCaseTemplate = .F.
		
		DO WHILE .T.
			IF !FILE(m.tcTestCaseTemplate)
				EXIT
			ENDIF
			EXIT
		ENDDO
		RETURN m.llValidDerivedTestCaseTemplate
	ENDPROC

	PROCEDURE validatetestclass
		LOCAL lcTestClassFile
		lcTestClassFile = This.classFullName()
		This.lValidclassname=.f.
		DO CASE 
			CASE !DIRECTORY(This.cTestFolder)
				this.icClassValidationMessage = "Directory " + This.cTestFolder + " does not exist."
			CASE EMPTY(ALLTRIM(This.cClassName))
				this.icClassValidationMessage = "Test class name is blank"
			CASE FILE(lcTestClassFile)
				this.icClassValidationMessage = "Test class file already exists."
			CASE AT(' ',ALLTRIM(This.cClassName))>0
				this.icClassValidationMessage = "Test class name cannot contain spaces."	
			OTHERWISE
				this.icClassValidationMessage = ""
				This.lValidclassname=.t.
		ENDCASE
		This.showControls()
		RETURN This.lValidClassname
		
	ENDPROC

	PROCEDURE validtemplatefile
		*
		*  RETURNs a logical value indicating whether the
		*  passed tcFileName is a valid FXUTestCase template
		*
		LPARAMETERS tcFileName
		
		LOCAL laLines[1], lcLine, llValid
		=ALINES(laLines,FILETOSTR(m.tcFileName),.t.)
		FOR EACH lcLine IN laLines
		*  IF UPPER(ALLTRIM(m.lcLine)) = "DEFINE CLASS " ;
		*      AND UPPER(" AS FXUTestCase OF FXUTestCase") $ UPPER(m.lcLine)
		
		  IF UPPER(ALLTRIM(m.lcLine)) = "DEFINE CLASS " ;
		  	AND (UPPER(" AS FXUTestCase OF FXUTestCase") $ UPPER(m.lcLine) ;
			OR this.TemplateClassInheritsFromFxuTestCase(m.lcLine))
		
		    *
		    *  MODIFY COMMAND FXUTestCase 
		    *  MODIFY COMMAND FXUTestCaseTemplate.TXT
		    *    XXDTES("FXUTESTCASETEMPLATE.TXT","DEFINE CLASS")
		    *
		    IF UPPER(JUSTEXT(m.tcFileName)) = "TXT"
		      *  make sure it has the <<test class>> text
		      llValid = "<<" $ m.lcLine ;
		                AND ">>" $ m.lcLine ;
		                AND AT_C("<<",m.lcLine) < AT_C(">>",m.lcLine)
		     ELSE
		      *  PRG
		      llValid = .t.
		    ENDIF
		    IF m.llValid
		      EXIT
		    ENDIF
		  ENDIF         
		ENDFOR
		
		RETURN m.llValid
		
		
		
		
	ENDPROC

	PROCEDURE zreadme
		#IF .f.
		
		Class:  FXU.VCX/frmGetTestClassTemplate
		
		
		#ENDIF
	ENDPROC

	PROCEDURE chkProcedure.Init
		IF VERSION(5)>=900
		  *
		  *  2 = Left Absolute
		  *  4 = Bottom Absolute
		  *
		  THIS.Anchor = 2 + 4
		ENDIF
	ENDPROC

	PROCEDURE chkProcedure.Refresh
		THIS.Enabled = THISFORM.lstTemplates.Value < 3
		
		
	ENDPROC

	PROCEDURE chkTab.Init
		IF VERSION(5)>=900
		  *
		  *  2 = Left Absolute
		  *  4 = Bottom Absolute
		  *
		  THIS.Anchor = 2 + 4
		ENDIF
	ENDPROC

	PROCEDURE chkTab.Refresh
		THIS.Enabled = THISFORM.lstTemplates.Value < 3
		
	ENDPROC

	PROCEDURE cmdAdd.Click
		_Screen.ActiveForm.AddTemplate()
	ENDPROC

	PROCEDURE cmdCreate.Click
		
		ThisForm.createTestClass()
		THISFORM.Hide()
		
		
		
		
		
	ENDPROC

	PROCEDURE cmdCreate.Init
		IF VERSION(5)>=900
		  *
		  *  4 = Bottom Absolute
		  *  8 = Right Absolute
		  *  2 = Left Absolute
		  *
		  THIS.Anchor = 2 + 8 + 4
		ENDIF
		
		
	ENDPROC

	PROCEDURE cmdEditTemplate.Click
		_Screen.ActiveForm.ModifyTemplate()
	ENDPROC

	PROCEDURE cmdPickTestFolder.Click
		ThisForm.pickTestFolder()
		
		 
	ENDPROC

	PROCEDURE cmdPickTestFolder.LostFocus
		IF !EMPTY(thisform.icclassvalidationmessage)
			thisform.txtTestClassName.SetFocus()
		ELSE
			thisform.cmdSelectCustomTemplate.SetFocus()
		ENDIF
		
	ENDPROC

	PROCEDURE cmdRemoveTemplate.Click
		_Screen.ActiveForm.RemoveTemplate()
	ENDPROC

	PROCEDURE cmdSelectCustomTemplate.Click
		LOCAL lcTemplateFile
		
		lcTemplateFile = THISFORM.GetYourFXUTemplate()
		
		IF NOT VARTYPE(m.lcTemplateFile) = "C" OR EMPTY(m.lcTemplateFile)
		  RETURN
		ENDIF
		
		THISFORM.iuRetVal = m.lcTemplateFile + ",.NULL.,.NULL."
		
		* THISFORM.Release()
		
		
	ENDPROC

	PROCEDURE cmdSelectCustomTemplate.Init
		IF VERSION(5)>=900
		  *
		  *  4 = Bottom Absolute
		  *  8 = Right Absolute
		  *  2 = Left Absolute
		  *
		  THIS.Anchor = 2 + 8 + 4
		ENDIF
		
	ENDPROC

	PROCEDURE cmdSelectFile.Click
		ThisForm.SelectFile()
		
		
	ENDPROC

	PROCEDURE cmdSelectFile.Init
		IF VERSION(5)>=900
		  *
		  *  4 = Bottom Absolute
		  *  8 = Right Absolute
		  *  2 = Left Absolute
		  *
		  THIS.Anchor = 2 + 8 + 4
		ENDIF
		
	ENDPROC

	PROCEDURE lblCopyExisting.Init
		IF VERSION(5)>=900
		  *
		  *  4 = Bottom Absolute
		  *  2 = Left Absolute
		  *
		  THIS.Anchor = 4 + 2
		ENDIF
	ENDPROC

	PROCEDURE lblTemplate.Init
		IF VERSION(5)>=900
		  *
		  *  4 = Bottom Absolute
		  *  2 = Left Absolute
		  *
		  THIS.Anchor = 4 + 2
		ENDIF
	ENDPROC

	PROCEDURE lstTemplates.Init
		LOCAL lnRow, lnCols
		lnRow = 0
		lnCols = 4
		
		lnRow = m.lnRow + 1
		DIMENSION THISFORM.iaTemplates[m.lnRow,m.lnCols]
		THISFORM.iaTemplates[m.lnRow,1] = "Standard FoxUnit test case template"
		THISFORM.iaTemplates[m.lnRow,2] = "FXUTestCaseTemplate.TXT"
		THISFORM.iaTemplates[m.lnRow,3] = FULLPATH(THISFORM.iaTemplates[m.lnRow,2])
		THISFORM.iaTemplates[m.lnRow,4] = .t.   &&& permanent
		
		lnRow = m.lnRow + 1
		DIMENSION THISFORM.iaTemplates[m.lnRow,m.lnCols]
		THISFORM.iaTemplates[m.lnRow,1] = "Minimal FoxUnit test case template"
		THISFORM.iaTemplates[m.lnRow,2] = "FXUTestCaseTemplate_Minimal.TXT"
		THISFORM.iaTemplates[m.lnRow,3] = FULLPATH(THISFORM.iaTemplates[m.lnRow,2])
		THISFORM.iaTemplates[m.lnRow,4] = .t.   &&& permanent
		
		THISFORM.inPermanentTemplates = ALEN(THISFORM.iaTemplates,1)
		
		THIS.RowSourceType = 5
		THIS.RowSource = "THISFORM.iaTemplates"
		
		THIS.Value = 1
		
		IF VERSION(5)>=900
		  *
		  *    1 = Top Absolute
		  *    2 = Left Absolute
		  *  128 = Right Relative
		  *    4 = Bottom Absolute
		  *
		  THIS.Anchor = 1 + 2 + 128 + 4
		ENDIF
		
		
	ENDPROC

	PROCEDURE lstTemplates.InteractiveChange
		THISFORM.Refresh()
		
	ENDPROC

	PROCEDURE lstTemplates.RightClick
		DEFINE POPUP pShortCut IN WINDOW (THISFORM.Name) SHORTCUT RELATIVE FROM MROW(THISFORM.Name),MCOL(THISFORM.Name)
		
		DEFINE BAR 1 OF pShortCut PROMPT "MODIFY COMMAND the indicated template" 
		ON SELECTION BAR 1 OF pShortCut _Screen.ActiveForm.ModifyTemplate() 
		
		DEFINE BAR 2 OF pShortCut PROMPT "Add a template file to this list" 
		ON SELECTION BAR 2 OF pShortCut _Screen.ActiveForm.AddTemplate() 
		
		DEFINE BAR 3 OF pShortCut PROMPT "Remove this template from the list" 
		ON SELECTION BAR 3 OF pShortCut _Screen.ActiveForm.RemoveTemplate() 
		
		ACTIVATE POPUP pShortCut
		
	ENDPROC

	PROCEDURE opgTemplateSource.Click
		ThisForm.showControls()
	ENDPROC

	PROCEDURE opgTemplateSource.Option2.Click
		DODEFAULT()
		ThisForm.selectFile()
		
	ENDPROC

	PROCEDURE opgTemplateSource.Option3.Click
		ThisForm.chooseExistingClass()
		
		
	ENDPROC

	PROCEDURE opgTemplateSource.Valid
		ThisForm.showControls()
	ENDPROC

	PROCEDURE txtExistingFile.InteractiveChange
		thisform.ValidateTestClass()
	ENDPROC

	PROCEDURE txtTestClassName.Valid
		thisform.cmdCreate.Enabled=thisform.ValidateTestClass()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fxufrmtestbroker AS fxufrmuser OF "fxu.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: runtest
		*m: runtheory
	*</DefinedPropArrayMethod>

	DataSession = 2
	DoCreate = .T.
	Height = 71
	Left = 0
	Name = "fxufrmtestbroker"
	Top = 0
	Visible = .F.
	Width = 359
	_memberdata = <VFPData>

		</VFPData>
	
	PROCEDURE Init
		PARAMETERS toFxuInstance
		
		IF !DODEFAULT(@m.toFxuInstance)
			RETURN .F.
		ENDIF
		
		this.DataSessionId = 1
	ENDPROC

	PROCEDURE runtest
		LPARAMETERS tcTestClass, tcUnused, toResult, tlAllowDebug
		
		IF !EMPTY(tlAllowDebug)
			tlAllowDebug = .t.
		ELSE
			tlAllowDebug = .f.
		ENDIF
		
		*LOCAL loTestCase, lcTestMethod, lcTestClassProgFile, lcOnError, lcClass
		LOCAL loTestCase, lcTestClassProgFile, lcClass
		
		lcClass = JUSTSTEM(m.tcTestClass) && Stripped path from class name. HAS
		
		lcTestClassProgFile = FORCEEXT(tcTestClass, "prg")
		
		loTestCase = NEWOBJECT(lcClass, lcTestClassProgFile,.NULL.,toResult, this.ioFxuInstance)
		
			*--------------------------------------------------------------------------------------
			* TestCase obtained the current test name from the result object. Check if there's a
			* corresponding Data array.
			*--------------------------------------------------------------------------------------
			Local lcTestData, llHasDataArray
			lcTestData = m.loTestCase.icCurrentTest + "_Data"
			If PemStatus (m.loTestCase, m.lcTestData, 5)
				llHasDataArray = .T.
			Else
				llHasDataArray = .F.
			EndIf
		
			*--------------------------------------------------------------------------------------
			* This is a theory...
			*--------------------------------------------------------------------------------------
			Local lnParam
			If m.llHasDataArray
				This.RunTheory ( ;
					 m.loTestCase ;
					,m.lcTestData ;
					,m.lcClass ;
					,m.lcTestClassProgFile ;
					,m.toResult ;
				)
			
			*--------------------------------------------------------------------------------------
			* ...it's a plain test
			*--------------------------------------------------------------------------------------
			Else
				loTestCase.Run()
			EndIf
		
		loTestCase.ilAllowDebug = tlAllowDebug
		
		
	ENDPROC

	PROCEDURE runtheory
		*========================================================================================
		* Runs a theory for every data point provided.
		*========================================================================================
		LParameter toSource, tcArray, tcClass, tcProgFile, toResult
		
			*--------------------------------------------------------------------------------------
			* Parameters are stored in a member array
			*--------------------------------------------------------------------------------------
			Local lnParam, lcParam
			lcParam = ""
			For lnParam = 1 to Alen(toSource.&tcArray, 2)
				If not Empty (m.lcParam)
					lcParam = m.lcParam + ", "
				EndIf
				lcParam = m.lcParam + ;
					"toSource." + m.tcArray + "[m.lnDataPoint," + Transform(m.lnParam) + "]"
			EndFor 
		
			*--------------------------------------------------------------------------------------
			* Check all data points for this theory
			*--------------------------------------------------------------------------------------
			Local loTestCase, lnDataPoint, lcResult, lnValue
			lcResult = ""
			For lnDataPoint = 1 to Alen(toSource.&tcArray, 1)
				loTestCase = NewObject ( ;
					m.tcClass, m.tcProgFile, null, m.toResult, this.ioFxuInstance ;
				)
				loTestCase.Run (&lcParam)
				If not Empty (toResult.icFailureErrorDetails)
					If not Empty (m.lcResult)
						lcResult = m.lcResult + Chr(13)+Chr(10) + Replicate("=",60) + Chr(13)+Chr(10)
					EndIf
					lcResult = m.lcResult	+"theory #" + Transform(m.lnDataPoint) + ": "
					For lnValue = 1 to Alen(toSource.&tcArray, 2)
						If m.lnValue > 1
							lcResult = m.lcResult + ", "
						EndIf
						lcResult = m.lcResult + Transform (m.toSource.&tcArray[m.lnDataPoint, m.lnValue])
					EndFor 
					lcResult = m.lcResult + Chr(13)+Chr(10) + toResult.icFailureErrorDetails 
				EndIf
			EndFor
		
			*--------------------------------------------------------------------------------------
			* Log combined test results
			*--------------------------------------------------------------------------------------
			toResult.icFailureErrorDetails = m.lcResult
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fxufrmuser AS fxufrmbase OF "fxu.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: iofxuinstance_assign
		*m: onsettingssave		&& Is called from within SettingsSave() and provides the opportunity to write settings to a cursor which will be saved to an FXUPersist*.xml file.
		*m: settingsrestore		&& Restores a set of name value pairs from an FXUPersist*.xml file.
		*m: settingssave		&& Stores a set of name value pairs into an FXUPersist*.xml file.
		*p: iofxuinstance		&& A reference to an FxuInstance object that must be passed to Init().
		*p: iofxuinstance_allow
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN iofxuinstance_allow
	Caption = "Form"
	DoCreate = .T.
	iofxuinstance = .NULL.		&& A reference to an FxuInstance object that must be passed to Init().
	iofxuinstance_allow = .F.
	Name = "fxufrmuser"
	_memberdata = <VFPData>
		<memberdata name="settingsrestore" type="method" display="SettingsRestore"/>
		<memberdata name="settingssave" type="method" display="SettingsSave"/>
		<memberdata name="iofxuinstance" type="property" display="ioFxuInstance"/>
		<memberdata name="onsettingssave" type="method" display="OnSettingsSave"/>
		<memberdata name="iofxuinstance_allow" type="property" display="ioFxuInstance_Allow"/>
		<memberdata name="iofxuinstance_assign" type="method" display="ioFxuInstance_Assign"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Init
		PARAMETERS toFXUInstance
		
		IF VARTYPE(m.toFXUInstance)!="O" OR ISNULL(m.toFXUInstance)
			ERROR 1924, "m.toFXUInstance"
			RETURN .F.
		ENDIF
		
		this.ioFxuInstance_Allow=.T.
		this.ioFxuInstance=m.toFXUInstance
		this.ioFxuInstance_Allow=.F.
	ENDPROC

	HIDDEN PROCEDURE iofxuinstance_assign
		LPARAMETERS vNewVal
		
		IF THIS.ioFxuInstance_Allow OR ISNULL(m.vNewVal)
			THIS.ioFxuInstance = m.vNewVal
		ELSE
			ERROR 1740, "ioFxuInstance"
		ENDIF
	ENDPROC

	PROTECTED PROCEDURE onsettingssave		&& Is called from within SettingsSave() and provides the opportunity to write settings to a cursor which will be saved to an FXUPersist*.xml file.
		PARAMETERS tcAlias
		
		IF VARTYPE(m.tcAlias)!="C" OR !USED(m.tcAlias)
			RETURN .F.
		ENDIF
		
		SELECT (m.tcAlias)
		SCATTER MEMVAR
		m.UserID = THIS.ioFxuInstance.UserId
		
		m.Setting = "THIS.Top = " + TRANSFORM(THIS.TOP)
		INSERT INTO (m.tcAlias) FROM MEMVAR
		m.Setting = "THIS.Left = " + TRANSFORM(THIS.LEFT)
		INSERT INTO (m.tcAlias) FROM MEMVAR
		m.Setting = "THIS.Height = " + TRANSFORM(THIS.HEIGHT)
		INSERT INTO (m.tcAlias) FROM MEMVAR
		m.Setting = "THIS.Width = " + TRANSFORM(THIS.WIDTH)
		INSERT INTO (m.tcAlias) FROM MEMVAR
	ENDPROC

	PROCEDURE settingsrestore		&& Restores a set of name value pairs from an FXUPersist*.xml file.
		PARAMETERS tcFile
		
		IF VARTYPE(m.tcFile)!="C" OR EMPTY(m.tcFile)
			m.tcFile = ".\FXUPersist" + this.Class + ".XML"
		ENDIF
		
		IF LEFT(m.tcFile, 1)=="."
			m.tcFile=FULLPATH(ADDBS(This.ioFxuInstance.DataPath) + m.tcFile)
		ELSE
			m.tcFile=FULLPATH(m.tcFile)
		ENDIF
		
		IF !FILE(m.tcFile, 1)
			This.ioFxuInstance.WriteDebug("fxu.vcx/fxufrmuser.SettingsRestore()", "File {" + m.tcFile + "} could not be found.")
			RETURN .F.
		ENDIF
		
		LOCAL lcAlias, lcCommand, loException as Exception
		m.lcAlias = JUSTSTEM(m.tcFile)+SYS(2015)
		TRY
			XMLTOCURSOR(m.tcFile, m.lcAlias, 512)
		CATCH TO m.loException
			This.ioFxuInstance.WriteDebug("fxu.vcx/fxufrmuser.SettingsRestore()", m.loException.Message)
		ENDTRY
		IF !USED(m.lcAlias)
			RETURN .F.
		ENDIF
		
		SELECT (m.lcAlias)
		SCAN FOR UPPER(ALLTRIM(USERID)) == UPPER(ALLTRIM(THIS.ioFxuInstance.UserId))
			m.lcCommand = ALLTRIM(Setting)
			TRY
				&lcCommand
			CATCH TO m.loException
				This.ioFxuInstance.WriteDebug("fxu.vcx/fxufrmuser.SettingsRestore()", m.loException.Message)
			ENDTRY
		ENDSCAN
		USE IN SELECT(m.lcAlias)
	ENDPROC

	PROCEDURE settingssave		&& Stores a set of name value pairs into an FXUPersist*.xml file.
		PARAMETERS tcFile
		
		IF VARTYPE(m.tcFile)!="C" OR EMPTY(m.tcFile)
			m.tcFile = ".\FXUPersist" + this.Class + ".XML"
		ENDIF
		
		IF LEFT(m.tcFile, 1)=="."
			m.tcFile=FULLPATH(ADDBS(This.ioFxuInstance.DataPath) + m.tcFile)
		ELSE
			m.tcFile=FULLPATH(m.tcFile)
		ENDIF
		
		LOCAL lcAlias, loException as Exception
		m.lcAlias = JUSTSTEM(m.tcFile)+SYS(2015)
		CREATE CURSOR (m.lcAlias) (USERID C(15), Setting M)
		
		IF FILE(m.tcFile)
			LOCAL lcAliasOld
			m.lcAliasOld=SYS(2015)
			TRY 
				XMLTOCURSOR(m.tcFile, m.lcAliasOld, 512)
			CATCH TO m.loException
				This.ioFxuInstance.WriteDebug("fxu.vcx/fxufrmuser.SettingsSave()", m.loException.Message)
			ENDTRY
			IF USED(m.lcAliasOld)
				SELECT * FROM (m.lcAlias) ;
				UNION ALL ;
				SELECT * FROM (m.lcAliasOld) ;
				INTO CURSOR (m.lcAlias) READWRITE
				USE IN SELECT(m.lcAliasOld)
			ENDIF
		ENDIF
		
		
		*
		*  delete all the existing settings for this user
		*
		DELETE ALL FOR UPPER(ALLTRIM(USERID)) == UPPER(ALLTRIM(THIS.ioFxuInstance.UserId)) IN (m.lcAlias)
		
		IF !this.OnSettingsSave(m.lcAlias)
			IF USED(m.lcAlias)
				USE IN SELECT(m.lcAlias)
				RETURN .F.
			ENDIF
		ENDIF
		
		TRY
			CURSORTOXML(m.lcAlias, m.tcFile, 1, 512, 0, "1")
		CATCH TO m.loException
		ENDTRY
		
		USE IN SELECT(m.lcAlias)
		
		IF VARTYPE(m.loException) = "O"
			This.ioFxuInstance.WriteDebug("fxu.vcx/fxufrmuser.SettingsSave()", m.loException.Message)
			MESSAGEBOX("Unable to save user settings because " + ;
				  CHR(13) + ;
				  m.loException.MESSAGE, ;
				  48, ;
				  "Please Note")
			RETURN .F.
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS fxuinstance AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: datapath_access
		*m: datapath_assign
		*m: foxunitpath_assign
		*m: fxunewobject		&& Creates and returns an object by class id, or .NULL. on failure.
		*m: isinpathconfig		&& Checks if a path specification occurs in the path configuration (SET("Path")) and returns a logical expression indicating success.
		*m: managefxuclasslibrary		&& Creates / updates the FoxUnit class factory table and returns a logical expression indicating success.
		*m: project_assign
		*m: userid_access
		*m: userid_assign
		*m: version_assign
		*m: writedebug		&& Writes debug information to the debug output window.
		*p: datapath		&& Returns the FoxUnit Data Path.
		*p: datasessionid		&& Sets or returns the data session ID operations performed by this object should run in.
		*p: foxunitpath		&& Returns the FoxUnit Path.
		*p: foxunitpath_allow
		*p: project		&& Returns the project object this instance is bound to.
		*p: project_allow
		*p: userid		&& Returns the current user name.
		*p: userid_allow
		*p: version		&& Returns the version of the currently running instance of FoxUnit.
		*p: version_allow
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN foxunitpath_allow,project_allow,userid_allow,version_allow
	datapath = 		&& Returns the FoxUnit Data Path.
	datasessionid = 1		&& Sets or returns the data session ID operations performed by this object should run in.
	foxunitpath = 		&& Returns the FoxUnit Path.
	foxunitpath_allow = .F.
	Name = "fxuinstance"
	project = .NULL.		&& Returns the project object this instance is bound to.
	project_allow = .F.
	userid = .NULL.		&& Returns the current user name.
	userid_allow = .F.
	version = 0.0		&& Returns the version of the currently running instance of FoxUnit.
	version_allow = .F.
	Width = 17
	_memberdata = <VFPData>
		<memberdata name="datapath" type="property" display="DataPath"/>
		<memberdata name="foxunitpath" type="property" display="FoxUnitPath"/>
		<memberdata name="foxunitpath_allow" type="property" display="FoxUnitPath_Allow"/>
		<memberdata name="foxunitpath_assign" type="method" display="FoxUnitPath_Assign"/>
		<memberdata name="version" type="property" display="Version"/>
		<memberdata name="project" type="property" display="Project"/>
		<memberdata name="project_assign" type="method" display="Project_Assign"/>
		<memberdata name="version_allow" type="property" display="Version_Allow"/>
		<memberdata name="version_assign" type="method" display="Version_Assign"/>
		<memberdata name="datapath_access" type="method" display="DataPath_Access"/>
		<memberdata name="datapath_assign" type="method" display="DataPath_Assign"/>
		<memberdata name="isinpathconfig" type="method" display="IsInPathConfig"/>
		<memberdata name="managefxuclasslibrary" type="method" display="ManageFxuClassLibrary"/>
		<memberdata name="writedebug" type="method" display="WriteDebug"/>
		<memberdata name="fxunewobject" type="method" display="FxuNewObject"/>
		<memberdata name="datasessionid" type="property" display="DataSessionId"/>
		<memberdata name="userid" type="property" display="UserId"/>
		<memberdata name="userid_access" type="method" display="UserId_Access"/>
		<memberdata name="userid_assign" type="method" display="UserId_Assign"/>
		<memberdata name="userid_allow" type="property" display="UserId_Allow"/>
		<memberdata name="project_allow" type="property" display="Project_Allow"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	HIDDEN PROCEDURE datapath_access
		*To do: Modify this routine for the Access method
		LOCAL lcResult
		IF !ISNULL(this.Project)
			m.lcResult=JUSTPATH(this.Project.Name)
		ELSE
			m.lcResult=SYS(5)+SYS(2003)
		ENDIF
		
		IF !DIRECTORY(m.lcResult, 1)
			ERROR 2145, "DataPath"
		ENDIF
		
		m.lcResult=ADDBS(m.lcResult)+"Tests"
		IF !DIRECTORY(m.lcResult, 1)
			MKDIR (m.lcResult)
		ENDIF
		
		RETURN m.lcResult
	ENDPROC

	HIDDEN PROCEDURE datapath_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		ERROR 1740, "DataPath"
	ENDPROC

	HIDDEN PROCEDURE foxunitpath_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		IF this.FoxUnitPath_Allow
			THIS.FoxUnitPath = m.vNewVal
		ELSE
			ERROR 1740, "FoxUnitPath"
		ENDIF
		
	ENDPROC

	PROCEDURE fxunewobject		&& Creates and returns an object by class id, or .NULL. on failure.
		*  This wrapper to the NEWOBJECT() function is a class
		*  factory based on \FoxUnit\FXUClassFactory.DBF, called 
		*  to instantiate one of the following:
		*    - The indicated class in the indicated .VCX
		*    - The indicated class in the indicated .PRG
		*    - The indicated .SCX
		*  and RETURNs an object reference to the indicated
		*  object (or .NULL. if something goes wrong)
		*
		*  The idea here is that, rather than hardcode the class
		*  and class library for the objects used in FoxUnit,
		*  the class name and class library are instead specified
		*  in the \FoxUnit\FXUClassFactory.DBF records.  So, if
		*  you decide to modify FoxUnit to meet your needs, rather
		*  than modifying the "official" FoxUnit code, you can
		*  just subclass any FoxUnit classes and specify your 
		*  subclass in the corresponding record of the
		*  \FoxUnit\FXUClassFactory.DBF table.
		*  To review this implementation in the FoxUnit code,
		*  just use the VFP Code References tool to do a search
		*  for "FXUNewObject" on the files in the \FoxUnit folder.
		*  
		*  The tcClassID parameter is REQUIRED, and specifies
		*  the FXUClassFactory.ClassID field value -- the
		*  class/.SCX in that FXUClassFactory record is 
		*  instantiated here:
		*    FXUClassFactory.DBF
		*        ClassID - specifies a unique string identifier
		*                  for the object to be instantiated
		*      ClassName - specifies the name of the class to 
		*                  be instantiated (if ClassLib is an
		*                  .SCX filename, leave ClassName blank)
		*       ClassLib - specifies the class library (.PRG or
		*                  .VCX) to be instantiated -- we STRONGLY
		*                  recommend that this class library be
		*                  in your VFP path, but you can specify
		*                  the full path if you want
		*
		*  NOTE that if the FXUClassFactory.ClassLib is an
		*  .SCX filename (and FXUClassFactory.ClassName is
		*  therefore blank/empty), the indicated form is
		*  instantiated but then goes immediately out of
		*  scope, so you should do something like this:
		*    PUBLIC goForm
		*    goForm = FXUNewObject("ClassID")
		*    goForm.Show()
		*
		*  
		*  USAGE
		*  =============================================
		*  LOCAL SomeObject
		*  SomeObject = FXUNewObject("ClassID")
		*  -OR-
		*  LOCAL SomeObject
		*  SomeObject = FXUNewObject("ClassID",InitParameter)
		*  -OR-
		*  LOCAL SomeObject
		*  SomeObject = FXUNewObject("ClassID",InitParameter1,InitParameter2)
		*
		*
		*  lParameters
		*         tcClassID (R) FXUClassFactory.ClassID value, indicating
		*                         the class/form to instantiate
		*  tuInitParameter1 (O) First parameter passed to the Init of
		*                         the class/form to instantiate
		*  tuInitParameter2 (O) Second parameter passed to the Init of
		*                         the class/form to instantiate
		*
		PARAMETERS tcClassID as String, tuInitParameter1 as Variant, tuInitParameter2 as Variant
		
		IF VARTYPE(m.tcClassID)!="C" OR EMPTY(m.tcClassID) 
			MESSAGEBOX("The required tcClassID parameter has not been passed!", 16, "FxuInstance.FxuNewObject()")
			RETURN .NULL.
		ENDIF
		
		SET DATASESSION TO this.DataSessionId
		
		&&	Get the FXUClassFactory.DBF open
		LOCAL lcFxuClassFactoryLocation, loException as Exception
		m.lcFxuClassFactoryLocation = ADDBS(this.FoxUnitPath) + "FXUClassFactory.dbf"
		
		this.WriteDebug("fxu.vcx/FxuInstance.FxuNewObject()", "Attempting to get class factory from {" + m.lcFxuClassFactoryLocation + "}.")
		USE IN SELECT("FXUClassFactory")
		TRY
			USE (m.lcFxuClassFactoryLocation) IN 0 SHARED NOUPDATE
		CATCH TO loException
		ENDTRY
		IF NOT USED("FXUClassFactory")
			IF VARTYPE(m.loException)=="O"
				MESSAGEBOX("Unable to open the FXUClassFactory.DBF table because " + CHR(13) + m.loException.Message, 16, "FxuInstance.FxuNewObject()")
			ELSE
				MESSAGEBOX("Unable to open the FXUClassFactory.DBF table for unknown reason.", 16, "FxuInstance.FxuNewObject()")
			ENDIF
		ENDIF
		IF NOT USED("FXUClassFactory")
			RETURN .NULL.
		ENDIF
		
		&&	Find the indicated record in FXUClassFactory.DBF
		LOCAL lcClassName, lcClassLib, lcSelect
		m.lcSelect=SELECT(0)
		SELECT FXUClassFactory
			LOCATE FOR UPPER(ALLTRIM(ClassID)) == UPPER(ALLTRIM(m.tcClassID))
			IF NOT FOUND()
				MESSAGEBOX("Unable to locate the class id {" + m.tcClassID + "} in the FXUClassFactory table.", 16, "FxuInstance.FxuNewObject()")
			ELSE
				lcClassName = UPPER(ALLTRIM(EVALUATE("FXUClassFactory.ClassName")))
				lcClassLib = UPPER(ALLTRIM(EVALUATE("FXUClassFactory.ClassLib")))
			ENDIF
		SELECT (m.lcSelect)
		USE IN SELECT("FXUClassFactory")
		IF EMPTY(m.lcClassLib)
			RETURN .NULL.
		ENDIF
		
		&&	instantiate the indicated object
		
		LOCAL loReturn, lnPCount
		loReturn = .NULL.
		lnPCount = PCOUNT()
		IF EMPTY(m.lcClassName) 
			&&	ClassLib is expected to be an .SCX file
			TRY
				DO CASE
					CASE m.lnPCount = 3
						DO FORM (m.lcClassLib) WITH m.tuInitParameter1, m.tuInitParameter2
					CASE m.lnPCount = 2
						DO FORM (m.lcClassLib) WITH m.tuInitParameter1
					OTHERWISE
						DO FORM (m.lcClassLib)
				ENDCASE
			CATCH TO loException
				loReturn = .NULL.
			ENDTRY
			IF VARTYPE(m.lcClassName) = "O"
				loReturn = m.lcClassName
			ENDIF
		ELSE
			&&	ClassLib is expected to be an .VCX file
			TRY
				DO CASE
					CASE m.lnPCount = 3
						loReturn = NEWOBJECT(m.lcClassName, m.lcClassLib, "", m.tuInitParameter1, m.tuInitParameter2)
					CASE m.lnPCount = 2
						loReturn = NEWOBJECT(m.lcClassName,m.lcClassLib,"", m.tuInitParameter1)
					OTHERWISE
						loReturn = NEWOBJECT(m.lcClassName,m.lcClassLib)
				ENDCASE
			CATCH TO loException
				loReturn = .NULL.
			ENDTRY
		ENDIF 
		
		IF VARTYPE(m.loException)=="O"
			ASSERT .F. MESSAGE "Unable to instantiate the requested {" + m.tcClassID + "} object because " + CHR(13) + loException.Message
		&&		MESSAGEBOX("Unable to instantiate the requested {" + m.tcClassID + "} object because " + CHR(13) + loException.Message, 16, "FxuInstance.FxuNewObject()")
		ENDIF
		
		RETURN m.loReturn
	ENDPROC

	PROCEDURE Init
		PARAMETERS tcVersion, tcFoxUnitPath, toProject
		
		IF VARTYPE(m.tcVersion)!="C" OR EMPTY(m.tcVersion)
			ASSERT .F. MESSAGE "fxu.vcx/FxuInstance.Init(): m.tcVersion is empty or invalid."
			RETURN .F.
		ENDIF
		
		IF VARTYPE(m.tcFoxUnitPath)!="C"
			ERROR 1759, "FoxUnitPath"
			RETURN .F.
		ENDIF
		
		IF !DIRECTORY(m.tcFoxUnitPath, 1)
			ERROR 1963
			RETURN .F.
		ENDIF
		
		*!*	* Check if path requirements mentioned in readme.txt are met
		*!*	IF !this.IsInPathConfig(m.tcFoxUnitPath)
		*!*		ASSERT .F. MESSAGE	"fxu.vcx/FxuInstance.Init(): m.tcFoxUnitPath {" + TRANSFORM(m.tcFoxUnitPath) + "} wasn't found in your path configuration - " + ;
		*!*							"please check your settings (see also step 1. of FoxUnit QuickStart in 'readme.txt')!"
		*!*	ENDIF
		
		this.Version_Allow=.T.
		this.Version=m.tcVersion
		this.Version_Allow=.F.
		
		this.FoxUnitPath_Allow=.T.
		this.FoxUnitPath=m.tcFoxUnitPath
		this.FoxUnitPath_Allow=.F.
		
		IF VARTYPE(m.toProject)=="O" AND !ISNULL(m.toProject)
			this.Project_Allow=.T.
			this.Project=m.toProject
			this.Project_Allow=.F.
		ENDIF
		
		RETURN this.ManageFxuClassLibrary()
	ENDPROC

	PROCEDURE isinpathconfig		&& Checks if a path specification occurs in the path configuration (SET("Path")) and returns a logical expression indicating success.
		PARAMETERS tcPath
		
		IF VARTYPE(m.tcPath)!="C" OR EMPTY(m.tcPath)
			ASSERT .F. MESSAGE "fxu.vcx/FxuInstance.IsInPathConfig(): m.tcPath {" + TRANSFORM(m.tcPath) + "} is empty or invalid!"
			RETURN .F.
		ENDIF
		
		m.tcPath=ADDBS(UPPER(ALLTRIM(m.tcPath)))
		
		LOCAL lnPath, lnPaths
		LOCAL ARRAY laPath[1]
		m.lnPath=0
		m.lnPaths=ALINES(m.laPath, SET("Path"), 9, ";")
		FOR m.lnPath = 1 TO m.lnPaths
			IF m.tcPath==UPPER(ADDBS(m.laPath[m.lnPath]))
				EXIT
			ENDIF
		ENDFOR
		
		RETURN BETWEEN(m.lnPath, 1, m.lnPaths)
	ENDPROC

	PROCEDURE managefxuclasslibrary		&& Creates / updates the FoxUnit class factory table and returns a logical expression indicating success.
		PARAMETERS tnOptions
		
		&&	m.tnOptions		Bitmasked options value:
		&&	0	(default)	None.
		&&	1	(Bit 0)		Only apply new class ids found in
		&&					FxuClassFactoryBase.dbf to FxuClassFactory.dbf
		
		IF VARTYPE(m.tnOptions)!="N"
			m.tnOptions=0
		ENDIF
		
		USE IN SELECT('FxuClassFactory')
		USE IN SELECT('FxuClassFactoryBase')
		
		LOCAL lcFxuClassFactoryLocation, loException as Exception
		
		lcFxuClassFactoryLocation = ADDBS(this.FoxUnitPath) + "FxuClassFactoryBase.dbf"
		this.WriteDebug("fxu.vcx/FxuInstance.ManageFxuClassFactory()", "Attempting to get class factory base from {" + m.lcFxuClassFactoryLocation + "}.")
		TRY
			USE (m.lcFxuClassFactoryLocation) IN 0 SHARED
		CATCH TO m.loException
		ENDTRY
		IF VARTYPE(m.loException)=="O" AND !USED("FxuClassFactoryBase")
			ASSERT .F. MESSAGE "Unable to open FxuClassFactoryBase because " + m.loException.Message + "!"
			RETURN .F.
		ENDIF
		
		lcFxuClassFactoryLocation = ADDBS(this.FoxUnitPath) + "FxuClassFactory.dbf"
		this.WriteDebug("fxu.vcx/FxuInstance.ManageFxuClassFactory()", "Attempting to get class factory from {" + m.lcFxuClassFactoryLocation + "}.")
		IF !FILE(lcFxuClassFactoryLocation, 1)
			SELECT FxuClassFactoryBase
			COPY TO (m.lcFxuClassFactoryLocation)
		ELSE
			USE (m.lcFxuClassFactoryLocation) IN 0 EXCLUSIVE
			
			IF BITTEST(m.tnOptions, 0)
				this.WriteDebug("fxu.vcx/FxuInstance.ManageFxuClassFactory()", "Applying only new class ids.")
				INSERT INTO FxuClassFactory ;
					SELECT * FROM FxuClassFactoryBase WHERE UPPER(ClassID) NOT IN ;
					(SELECT UPPER(ClassID) FROM FxuClassFactory)
			ELSE
				&& Create temp index
				LOCAL lcIdxFile
				m.lcIdxFile=FORCEEXT(m.lcFxuClassFactoryLocation, "idx")
				IF FILE(m.lcIdxFile, 1)
					DELETE FILE (m.lcIdxFile)
				ENDIF
				SELECT ('FxuClassFactory')
				INDEX ON UPPER(classid) TO (m.lcIdxFile)
				
				&&	Use temp index with relation
				SET RELATION TO UPPER(classid) INTO 'FxuClassFactory' IN 'FxuClassFactoryBase'
				
				&&	Update (add or replace) class factory working table
				SELECT ('FxuClassFactoryBase')
				SCAN
					IF EOF('FxuClassFactory')
						INSERT INTO FxuClassFactory	(classid,									classname,									classlib) ;
											VALUES	(EVALUATE("FxuClassFactoryBase.Classid"),	EVALUATE("FxuClassFactoryBase.classname"),	EVALUATE("FxuClassFactoryBase.classlib"))
					ELSE
						REPLACE	classname	WITH EVALUATE("FxuClassFactoryBase.classname") ;
							  , classlib	WITH EVALUATE("FxuClassFactoryBase.classlib") ;
						NEXT 1 IN 'FxuClassFactory'
					ENDIF
				ENDSCAN
				
				&&	Clean up
				SET RELATION TO
				SELECT ('FxuClassFactory')
				SET INDEX TO
				DELETE FILE (m.lcIdxFile)
			ENDIF
		ENDIF
		
		USE IN SELECT('FxuClassFactory')
		USE IN SELECT('FxuClassFactoryBase')
	ENDPROC

	HIDDEN PROCEDURE project_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		IF this.Project_Allow
			THIS.Project = m.vNewVal
		ELSE
			ERROR 1740, "Project"
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE userid_access
		*To do: Modify this routine for the Access method
		IF ISNULL(this.UserId)
			this.UserId_Allow=.T.
			this.UserId = ALLTRIM(TRANSFORM(SYS(0)))
			IF !("#" $ this.UserId)
				*  machine information not assigned by the network,
				*  or network shell not loaded, or standalone machine
				this.UserId = SPACE(0)
			ELSE
				this.UserId = ALLTRIM(SUBSTRC(this.UserId, AT_C("#", this.UserId) + 1))
			ENDIF
			this.UserId_Allow=.F.
		ENDIF
		
		RETURN this.UserId
	ENDPROC

	HIDDEN PROCEDURE userid_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		IF this.UserId_Allow
			this.UserId=m.vNewVal
		ELSE
			ERROR 1740, "UserId"
		ENDIF
	ENDPROC

	HIDDEN PROCEDURE version_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		IF this.Version_Allow
			THIS.Version = m.vNewVal
		ELSE
			ERROR 1740, "Version"
		ENDIF
		
	ENDPROC

	PROCEDURE writedebug		&& Writes debug information to the debug output window.
		PARAMETERS tcLocation, tcMessage
		
		IF VARTYPE(m.tcLocation)!="C" OR EMPTY(m.tcLocation)
			m.tcLocation="<Unknown location>"
		ENDIF
		
		DEBUGOUT DATETIME(), m.tcLocation, m.tcMessage
	ENDPROC

ENDDEFINE
